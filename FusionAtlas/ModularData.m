(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["FusionAtlas`ModularData`",{"FusionAtlas`","FusionAtlas`Bigraphs`","FusionAtlas`GraphPairs`","FusionAtlas`TensorSolver`","FusionAtlas`FormalCodegrees`","FusionAtlas`InductionMatrix`","FusionAtlas`DisplayGraphs`"}];


FindModularData::usage="FindModularData[X_] computes all possible modular data for the centre; the argument X may be a fusion ring and induction matrix, a fusion ring, the rank 3 tensor of fusion multiplicities, a matrix of fusion multiplicities for a single object, or a principal graph.";


Begin["`Private`"];


Clear[\[Zeta]]
\[Zeta][n_]:=\[Zeta][n]=With[{p=Evaluate[Cyclotomic[n,#]]&},With[{d=Module[{m},Exponent[p[m],m]]},
AlgebraicNumber[Root[p,d],{0,1}~Join~Table[0,{d-2}]]]]


\[Zeta]inv[n_]:=\[Zeta]inv[n]=\[Zeta][n]^-1


Clear[identify\[Zeta]]
identify\[Zeta][z_]:=identify\[Zeta][z]=Module[{n=1},While[z=!=\[Zeta][n]\[And](n<=2\[Or]z=!=\[Zeta][n][[1]]),n++];n]


(*Clear[cachedToNumberField]*)
cachedToNumberField[X_,Y_]:=Module[{result},
result=ToNumberField[X,Y];
If[!MatchQ[result,_ToNumberField],
cachedToNumberField[X,Y]=result
];
result
]


ToCyclotomicField[X_List]:=ToCyclotomicField[X,1][[1]]
ToCyclotomicField[X_List?MatrixQ]:=Partition[ToCyclotomicField[Flatten[X]],Length[X[[1]]]]
ToCyclotomicField[{},n_]:={{},n}
ToCyclotomicField[x_?NumericQ]:=ToCyclotomicField[{x}]
ToCyclotomicField[{x_,z___},n_]:=Module[{tnf,k=1,zt,p},
Quiet[
tnf=cachedToNumberField[x,\[Zeta][n]];
While[MatchQ[tnf,_ToNumberField],
k++;
n0=k n;
tnf=cachedToNumberField[x,\[Zeta][k n]]
],
ToNumberField::nnfel];
{zt,p}=ToCyclotomicField[{z},k n];
{{AlgebraicNumberPolynomial[tnf,\[Zeta][p]^(p/(k n))]}~Join~zt,p}
]


PrimePowers[n_]:=#[[1]]^#[[2]]&/@FactorInteger[n]


LiftToCommonCyclotomicField[x_]:=Module[{exponents,N},
exponents=Union[identify\[Zeta]/@Union[Cases[x,AlgebraicNumber[a_,___]:>a,\[Infinity]]]];
N=LCM@@({1}~Join~exponents);
If[exponents==={N},
x,
x/.a:AlgebraicNumber[z_,_]:>If[identify\[Zeta][z]==N,a,AlgebraicNumberPolynomial[a,\[Zeta][N]^(N/identify\[Zeta][z])]]
]
]


SetAttributes[AlgebraicConjugate,Listable]
AlgebraicConjugate[n_Integer]:=n


CyclotomicOrder[x_]:=CyclotomicOrder[x]=Round[(2\[Pi])/Arg[x]]


AlgebraicConjugate[a_AlgebraicNumber]:=AlgebraicNumberPolynomial[a,\[Zeta]inv[CyclotomicOrder[a[[1]]]]]
AlgebraicConjugate[x:(_Integer|_Rational)]:=x


UniqueGaloisConjugate[a:AlgebraicNumber[x_,__]]:=ToNumberField[RootReduce[a]/.z:Power[_,1/2]:>-z,x]


dataDirectory=FileNameJoin[{FusionAtlasDirectory[],"modularData"}];
If[!FileExistsQ[dataDirectory],CreateDirectory[dataDirectory]];


GZIP[data_,filename_]/;StringTake[filename,-3]==".gz":=AbortProtect[Module[{},
Put[data,StringDrop[filename, -3]];
Run["cd "<>DirectoryName[filename]<>" && gzip "<>StringDrop[filename, -3]];
]]


ImportGZIP[filename_]/;StringTake[filename,-3]==".gz":=Module[{unzipped="/tmp/unzipped"<>ToString[$KernelID]<>"-"<>StringDrop[StringDrop[filename, -3],StringLength[DirectoryName[filename]]],result},
Run["cd "<>DirectoryName[filename]<>" && gzip -cd "<>filename<>" > "<>unzipped];
result=Get[unzipped];
DeleteFile[unzipped];
result
]


SHA1[x_]:=IntegerString[Hash[x,"SHA1"],16,32]


GAP[SL[2,Subscript[Z, N_]]]:="Group([[[0,1],[-1,0]],[[1,1],[0,1]]]*One(Integers mod "<>ToString[N]<>"))"


GAPPath="~/gap/gap";


Execute[cmd_]:=Module[{lines,return},
Print["Calling GAP:"];
Print[cmd];
return=Run["echo '"<>cmd<>"' | "<>GAPPath<>" -x 10000 -o 16g > /tmp/gap"<>ToString[$KernelID]<>".out"];
lines=StringSplit[Import["/tmp/gap"<>ToString[$KernelID]<>".out","String"],"\n"];
If[return!=0,
If[Count[lines,l_/;!StringFreeQ[l,"+++++++"]]<3,
Print["It looks like something went wrong running GAP (error code "<>ToString[return]<>"). Please check that you have GAP installed, and modify FusionAtlas`ModularData`Private`GAPPath if necessary."];
Print/@lines;
];
];
lines
]


(* This uses Vahid Dabbaghian's RepSn package for GAP: http://www.gap-system.org/Packages/repsn.html *)


ExplicitGenerators[q_][k_]/;PrimePowerQ[q]:=ExplicitGenerators[q][k]=Module[{out,S,T,N,i,Q,invQ},
out=Execute["
LoadPackage(\"repsn\");
S:=[[0,1],[-1,0]]*One(Integers mod "<>ToString[q]<>");;
T:=[[1,1],[0,1]]*One(Integers mod "<>ToString[q]<>");;
G:=Group([S,T]);;
rep:=IrreducibleAffordingRepresentation(Irr(G)["<>ToString[k]<>"]);;
Print(\"+++++++\");
S^rep;
Print(\"+++++++\");
T^rep;
Print(\"+++++++\");
"];
{S,T}=(contextToExpression/@(StringSplit[(StringJoin@@out),"+++++++"][[{2,3}]]/.s_String:>(StringReplace[s,{"gap> ":>"","[":>"{","]":>"}","E("~~n:(DigitCharacter..)~~")":>"\[Zeta]["<>n<>"]"}])));
N=LCM[q,Sequence@@(identify\[Zeta]/@Union[Cases[{S,T},a_AlgebraicNumber:>a[[1]],\[Infinity]]])];
Print["Lifting to Q[\[Zeta]["<>ToString[N]<>"]]"];
{S,T}={S,T}/.a:AlgebraicNumber[z_,_]:>AlgebraicNumberPolynomial[a,\[Zeta][N]^(N/identify\[Zeta][z])];
{lastS,lastT}={S,T};
Print["Computing eigenspaces..."];
eigenspaces=Table[(*Print[i];*)NullSpace[T-\[Zeta][N]^(i N/q) IdentityMatrix[Length[T]],"Method"->"OneStepRowReduction"],{i,0,q-1}];
Q=Transpose[Join@@eigenspaces];
Print["Inverting change of basis..."];
lastQ=Q;
invQ=Inverse[Q,"Method"->"OneStepRowReduction"];
Print["Done!"];
{invQ.S.Q,invQ.T.Q}
]


SaveGenerators[]:=AbortProtect[Put[SubValues[ExplicitGenerators],FileNameJoin[{dataDirectory,"explicitGenerators.m"}]]]
LoadGenerators[]:=Module[{filename=FileNameJoin[{dataDirectory,"explicitGenerators.m"}]},
If[FileExistsQ[filename],
(SubValues[ExplicitGenerators]=Get[filename]~Join~SubValues[ExplicitGenerators];)
]
]


LoadGenerators[]


Clear[ReadCharacterTable]
ReadCharacterTable[gapName_]:=ReadCharacterTable[gapName]=Module[{lines},
lines=Execute["Display(CharacterTable("<>gapName<>"));"];
Print["Calculated the character table for "<>gapName<>":"];
Print[TableForm[lines]];
lines=Take[lines,{3,-1}+Flatten[Position[lines,s_/;StringMatchQ[s,"gap>"~~___],{1},Heads->False]]];
lines
]


VerifyUnitarity[table_]:=Module[{table1,M,conjugacyClassSizes},
table1=ToCyclotomicField[table];
M=AlgebraicConjugate[Transpose[table1]].table1;
conjugacyClassSizes=Table[M[[k,k]],{k,1,Length[M]}];
conjugacyClassSizes=conjugacyClassSizes[[1]]/conjugacyClassSizes;
table1.AlgebraicConjugate[conjugacyClassSizes Transpose[table1]]/(Plus@@conjugacyClassSizes)===IdentityMatrix[Length[M]]
]


VerifyUnitarityNumerically[table_]:=Module[{table1,M,conjugacyClassSizes},
table1=N[table,100];
M=Conjugate[Transpose[table1]].table1;
conjugacyClassSizes=Table[M[[k,k]],{k,1,Length[M]}];
conjugacyClassSizes=Round[conjugacyClassSizes[[1]]/conjugacyClassSizes];
Union[Flatten[Chop[table1.Conjugate[conjugacyClassSizes Transpose[table1]]/(Plus@@conjugacyClassSizes)-IdentityMatrix[Length[M]]]]]==={0}
]


contextToExpression[X_]:=Module[{result},
ToExpression[X]/.Global`\[Zeta]->\[Zeta]
]


(*Clear[CharacterTable]*)
CharacterTable[gapName_]:=CharacterTable[gapName]=Module[{lines,Xpos,conjugacyClasses,representations,values,numberOfConjugacyClasses,parseRepresentation,result},
lines=ReadCharacterTable[gapName];
Xpos=Flatten[Position[lines,s_String/;StringMatchQ[s,"X."~~___]]];
conjugacyClasses=lines[[Min[Xpos]-2]];
representations=lines[[Xpos]];
values=If[Max[Xpos]+1>Length[lines],{},Cases[Drop[lines,Max[Xpos]+1],s_String/;!StringMatchQ[s,Whitespace~~"= "~~___]]];
numberOfConjugacyClasses=Length[StringSplit[conjugacyClasses,Whitespace]];

values=StringSplit[#," = "]/.{n_,v_}:>n->(contextToExpression[StringReplace[v,"E("~~k:(DigitCharacter..)~~")":>"\[Zeta]["<>k<>"]"]])&/@values;

parseRepresentation[line_]:=StringReplace[Rest[StringSplit[line,Whitespace]],{"."->"0"}]/.{n_String/;StringMatchQ[n,NumberString]:>contextToExpression[n],
n_String/;StringMatchQ[n,"-"~~LetterCharacter..]:>-(StringDrop[n,1]/.values),
n_String/;StringMatchQ[n,"\\*"~~LetterCharacter..]:>UniqueGaloisConjugate[(StringDrop[n,1]/.values)],
n_String/;StringMatchQ[n,"-\\*"~~LetterCharacter..]:>-UniqueGaloisConjugate[(StringDrop[n,2]/.values)],
n_String/;StringMatchQ[n,"/"~~LetterCharacter..]:>AlgebraicConjugate[(StringDrop[n,1]/.values)],
n_String/;StringMatchQ[n,"-/"~~LetterCharacter..]:>-AlgebraicConjugate[(StringDrop[n,2]/.values)],
n_String/;StringMatchQ[n,LetterCharacter..]:>(n/.values)};

result=parseRepresentation/@representations;
If[!VerifyUnitarityNumerically[result],Print["Something went wrong; the character table doesn't look right: "];Print[result];
Print[TableForm[lines]];
Abort[]];
result
]


SaveCharacterTables[]:=AbortProtect[Put[DownValues[CharacterTable],FileNameJoin[{dataDirectory,"characterTables.m"}]]]
LoadCharacterTables[]:=
Module[{filename=FileNameJoin[{dataDirectory,"characterTables.m"}]},
If[FileExistsQ[filename],
(DownValues[CharacterTable]=Get[filename]~Join~DownValues[CharacterTable];)
]
]


LoadCharacterTables[];


Clear[ConjugacyClassOf]
ConjugacyClassOf[q_][m_]:=ConjugacyClassOf[q][m]=Module[{cmd,lines},
cmd="Position(ConjugacyClasses("<>GAP[SL[2,Subscript[Z, q]]]<>"),ConjugacyClass("<>GAP[SL[2,Subscript[Z, q]]]<>","<>StringReplace[ToString[m],{"{"->"[","}"->"]"}]<>"*One(Integers mod "<>ToString[q]<>")));";
lines=Execute[cmd];
ToExpression[StringDrop[lines[[-2]],5]]
]


SaveConjugacyClasses[]:=Module[{},
AbortProtect[Put[SubValues[ConjugacyClassOf],FileNameJoin[{dataDirectory,"conjugacyClasses.m"}]]];
AbortProtect[Put[Cases[DownValues[ConjugacyClassesOfPowersOfT],r_/;FreeQ[r,Blank]],FileNameJoin[{dataDirectory,"conjugacyClassesOfPowersOfT.m"}]]];
AbortProtect[Put[Cases[DownValues[ConjugacyClassesOfGalois],r_/;FreeQ[r,Blank]],FileNameJoin[{dataDirectory,"conjugacyClassesOfGalois.m"}]]];
]
LoadConjugacyClasses[]:=Module[{},
If[FileExistsQ[FileNameJoin[{dataDirectory,"conjugacyClasses.m"}]],
SubValues[ConjugacyClassOf]=Get[FileNameJoin[{dataDirectory,"conjugacyClasses.m"}]]~Join~SubValues[ConjugacyClassOf];
];
If[FileExistsQ[FileNameJoin[{dataDirectory,"conjugacyClassesOfPowersOfT.m"}]],
DownValues[ConjugacyClassesOfPowersOfT]=Get[FileNameJoin[{dataDirectory,"conjugacyClassesOfPowersOfT.m"}]]~Join~DownValues[ConjugacyClassesOfPowersOfT];
];
If[FileExistsQ[FileNameJoin[{dataDirectory,"conjugacyClassesOfGalois.m"}]],
DownValues[ConjugacyClassesOfGalois]=Get[FileNameJoin[{dataDirectory,"conjugacyClassesOfGalois.m"}]]~Join~DownValues[ConjugacyClassesOfGalois];
];
]


ConjugacyClassesOfGalois[q_]/;PrimePowerQ[q]:=ConjugacyClassesOfGalois[q]=Module[{galois,cmd,lines},
galois=StringReplace[ToString[GaloisGroup[q]],{"{"->"[","}"->"]"}];
cmd = "m := "<>ToString[q] <>";; G := Group([[[0,1],[-1,0]],[[1,1],[0,1]]]*One(Integers mod m));; cc := ConjugacyClasses(G);; List("<>galois<>", n -> Position(cc,ConjugacyClass(G,[[n, 0], [0, n^(-1)]]*One(Integers mod m))));";
lines=Execute[cmd];
Rule@@#&/@Transpose[{GaloisGroup[q],ToExpression[StringReplace[StringDrop[lines[[-2]],5],{"["->"{","]"->"}"}]]}]
]


ConjugacyClassesOfPowersOfT[q_]/;PrimePowerQ[q]:=ConjugacyClassesOfPowersOfT[q]=Module[{cmd,lines},
cmd = "m := "<>ToString[q] <>";; G := Group([[[0,1],[-1,0]],[[1,1],[0,1]]]*One(Integers mod m));; cc := ConjugacyClasses(G);; List([0..(m-1)], n -> Position(cc,ConjugacyClass(G,[[1, n], [0, 1]]*One(Integers mod m))));";
lines=Execute[cmd];
ToExpression[StringReplace[StringDrop[lines[[-2]],5],{"["->"{","]"->"}"}]]
]


LoadConjugacyClasses[]


GaloisMatrix[n_,l_]:=GaloisMatrix[n,l]=With[{c={{-1,0},{0,-1}},s={{0,1},{-1,0}},t={{1,1},{0,1}}},Mod[c.s.{{1,PowerMod[l,-1,n]},{0,1}}.s.{{1,l},{0,1}}.s.{{1,PowerMod[l,-1,n]},{0,1}},n]]


GaloisInRepresentation[q_/;PrimePowerQ[q],k_Integer (* which irrep *),l_(* which Galois element *)]:=GaloisInRepresentation[q,k,l]=Module[{S,T},
{S,T}=ExplicitGenerators[q][k];
MatrixPower[S,3].MatrixPower[T,PowerMod[l,-1,q]].S.MatrixPower[T,l].S.MatrixPower[T,PowerMod[l,-1,q]]
]


BlockDiagonalMatrix=With[{r=MapIndexed[#2[[1]] {1,1}->#&,#,1]},Normal[SparseArray`SparseBlockMatrix[r]]]&;


GaloisInRepresentation[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *),l_ (* which Galois element *)]:=
KroneckerProduct@@Table[GaloisInRepresentation[p[[1]],p[[2]],Mod[l,p[[1]]]]/.a_AlgebraicNumber:>AlgebraicNumberPolynomial[a,\[Zeta][n]^(n/identify\[Zeta][a[[1]]])],{p,Transpose[{PrimePowers[n],ks}]}]
GaloisInRepresentation[n_Integer,Vs:{{__Integer}..},l_]:=BlockDiagonalMatrix[Table[GaloisInRepresentation[n,V,l],{V,Vs}]]


TraceOfGalois[q_/;PrimePowerQ[q],k_Integer(* which irrep *),l_ (* which Galois element *)]:=CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[k,l/.ConjugacyClassesOfGalois[q]]]


TraceOfGalois[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *),l_ (* which Galois element *)]:=TraceOfGalois[n,ks,l]=
Product[TraceOfGalois[p[[1]],p[[2]],Mod[l,p[[1]]]],{p,Transpose[{PrimePowers[n],ks}]}]
TraceOfGalois[n_Integer,Vs:{{__Integer}..},l_]:=Sum[TraceOfGalois[n,V,l],{V,Vs}]


GaloisGroup[n_]:=GaloisGroup[n]=Cases[Table[i,{i,1,n-1}],i_/;GCD[i,n]==1]


GaloisConjugates[n_][AlgebraicNumber[s_,a_]]/;s==\[Zeta][n][[1]]:=Table[AlgebraicNumber[s,Flatten[Transpose[{a}~Join~Table[0,{m-1},{Length[a]}]]]],{m,GaloisGroup[n]}]
GaloisConjugates[n_][k:(_Integer|_Rational)]:=Table[k,{m,GaloisGroup[n]}]


GaloisInverse[n_][l_]:=PowerMod[l,-1,n]


GaloisAction[n_][l_][a:AlgebraicNumber[r_,x_]]/;r==\[Zeta][n][[1]]:=GaloisAction[n][l][a]=AlgebraicNumberPolynomial[a,\[Zeta][n]^l]
GaloisAction[n_][l_][a:(_Integer|_Rational)]:=a


Clear[GaloisGroupRepresentatives]
GaloisGroupRepresentatives[n_]:=GaloisGroupRepresentatives[n]=Module[{iterators,a},
iterators=Table[{a[i],0,MultiplicativeOrder[GaloisGroupGenerators[n][[i]],n]-1},{i,1,Length[GaloisGroupGenerators[n]]}];
#[[2]]->#[[1]]&/@Tally[Flatten[Table[{Table[a[i],{i,1,Length[GaloisGroupGenerators[n]]}],Mod[Product[GaloisGroupGenerators[n][[i]]^a[i],{i,1,Length[GaloisGroupGenerators[n]]}],n]},Evaluate[Sequence@@iterators]],Length[GaloisGroupGenerators[n]]-1],#1[[2]]==#2[[2]]&][[All,1]]
]


GaloisGroupElementAsProductOfGenerators[n_,k_]:=k/.GaloisGroupRepresentatives[n]


Clear[GeneratorsOfUnitsModPrimePower]


GeneratorsOfUnitsModPrimePower[q_]/;PrimePowerQ[q]\[And]FactorInteger[q][[1,1]]!=2:=GeneratorsOfUnitsModPrimePower[q]=Module[{p,n=1},
p=FactorInteger[q][[1,1]];
While[!CoprimeQ[n,q]\[Or]MultiplicativeOrder[n,q]!=q/p (p-1),n++];
{n}
]


GeneratorsOfUnitsModPrimePower[2]={};
GeneratorsOfUnitsModPrimePower[4]={3};


GeneratorsOfUnitsModPrimePower[q_]/;PrimePowerQ[q]\[And]FactorInteger[q][[1,1]]==2/;q>=8:=(*GeneratorsOfUnitsModPrimePower[q]=*){3}~Join~Take[Complement[{q/2-1,q/2+1,q-1},PowerMod[3,Range[q-1],q]],1]


GaloisGroupGenerators[n_]:=Module[{factors=#[[1]]^#[[2]]&/@FactorInteger[n],m},
m=Length[factors];
Flatten[Table[ChineseRemainder[(g-1)UnitVector[m,i]+1,factors],{i,1,m},{g,GeneratorsOfUnitsModPrimePower[factors[[i]]]}]]
]



SInRepresentation[q_/;PrimePowerQ[q],k_Integer (* which irrep *)]:=ExplicitGenerators[q][k][[1]]
TInRepresentation[q_/;PrimePowerQ[q],k_Integer (* which irrep *)]:=ExplicitGenerators[q][k][[2]]


(* Sometimes S will lie in an even larger number field. *)


SInRepresentation[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *)]:=
LiftToCommonCyclotomicField[KroneckerProduct@@Table[SInRepresentation[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],ks}]}]]
SInRepresentation[n_Integer,Vs:{{__Integer}..}]:=LiftToCommonCyclotomicField[BlockDiagonalMatrix[Table[SInRepresentation[n,V],{V,Vs}]]]
TInRepresentation[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *)]:=
KroneckerProduct@@Table[TInRepresentation[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],ks}]}]/.a_AlgebraicNumber:>AlgebraicNumberPolynomial[a,\[Zeta][n]^(n/identify\[Zeta][a[[1]]])]
TInRepresentation[n_Integer,Vs:{{__Integer}..}]:=BlockDiagonalMatrix[Table[TInRepresentation[n,V],{V,Vs}]]


Clear[FPDimensions,GlobalDimension,DimensionsFromFusionRules,DimensionsFromInductionMatrix,DimensionsFromFusionRulesAndInductionMatrix]


FPDimensions[fr_FusionRules]:=FPDimensions[fr]=Max[Cases[Eigenvalues[#],x_/;Im[x]==0]]&/@fr[[2,1,2]]
GlobalDimension[fr_FusionRules]:=GlobalDimension[fr]=ToCyclotomicField[Norm[FPDimensions[fr]]^2][[1]]


DimensionsFromFusionRules[fusion_]:=DimensionsFromFusionRules[fusion]=Module[{\[ScriptCapitalD],N},
\[ScriptCapitalD]=GlobalDimension[fusion];
N=Switch[\[ScriptCapitalD],_AlgebraicNumber,identify\[Zeta][\[ScriptCapitalD][[1]]],_,1];
{\[ScriptCapitalD],cachedToNumberField[#,\[Zeta][N]]&/@FPDimensions[fusion]}
]


DimensionsFromFusionRulesAndInductionMatrix[fusion_,induction_]:=DimensionsFromFusionRulesAndInductionMatrix[fusion, induction]=Module[{\[ScriptCapitalD],dims},
{\[ScriptCapitalD],dims}=DimensionsFromFusionRules[fusion];
{\[ScriptCapitalD],Transpose[induction].dims}
]


DimensionsFromInductionMatrix[inductionMatrix_]:=DimensionsFromInductionMatrix[inductionMatrix]=Module[{dimensions,n},
dimensions=RootReduce[Together[Eigenvectors[Transpose[inductionMatrix].inductionMatrix]]];
dimensions=Plus@@(RootReduce[#/Norm[#]]&/@Cases[dimensions,d_/;And@@(NonNegative[d])]);
dimensions=RootReduce[dimensions/Min[dimensions]];
dimensions=ToCyclotomicField[dimensions];
n=Cases[dimensions,a_AlgebraicNumber:>identify\[Zeta][a[[1]]],1][[1]];
{n,{cachedToNumberField[Sum[d^2,{d,dimensions}]^(1/2),\[Zeta][n]],dimensions}}
]


DimensionsFromInductionMatrix[N_,inductionMatrix_]:=DimensionsFromInductionMatrix[N,inductionMatrix]=
Module[{n,dims},
{n,dims}=DimensionsFromInductionMatrix[inductionMatrix];
dims/.x_AlgebraicNumber:>AlgebraicNumberPolynomial[x,\[Zeta][N]^(N/n)]
]


SaveDimensionsFromInductionMatrix[]:=(LoadDimensionsFromInductionMatrixOnce[];AbortProtect[Put[DownValues[DimensionsFromInductionMatrix],FileNameJoin[{dataDirectory,"dimensionsFromInductionMatrix.m"}]]])
LoadDimensionsFromInductionMatrixOnce[]:=LoadDimensionsFromInductionMatrixOnce[]=LoadDimensionsFromInductionMatrix[]
LoadDimensionsFromInductionMatrix[]:=Module[{filename=FileNameJoin[{dataDirectory,"dimensionsFromInductionMatrix.m"}]},
If[FileExistsQ[filename],
DownValues[DimensionsFromInductionMatrix]=Get[filename]~Join~DownValues[DimensionsFromInductionMatrix]
];
]


Clear[CheckGaloisVerlinde]


CheckGaloisVerlinde[inductionMatrix_]:=Module[{n,dimensions},
{n,dimensions}=DimensionsFromInductionMatrix[inductionMatrix];
CheckGaloisVerlinde[n,dimensions]
]


CheckGaloisVerlinde[fusion_FusionRules,inductionMatrix_?MatrixQ]:=Module[{N,dimensions},
dimensions=DimensionsFromFusionRulesAndInductionMatrix[fusion,inductionMatrix];
N=Switch[dimensions[[1]],_AlgebraicNumber,identify\[Zeta][dimensions[[1,1]]],_,1];
CheckGaloisVerlinde[N,dimensions]
]


CheckGaloisVerlinde[n_Integer,dimensions:{_?NumericQ,{___?NumericQ}}]:=CheckGaloisVerlinde[n,dimensions]=Module[{S,galoisElements},
S[1]=dimensions[[2]]/dimensions[[1]];
S[l_]:=S[l]=GaloisAction[n][l]/@S[1];
galoisElements=(Sort[#[[2,All,1]]]&/@Normal[GroupBy[Table[{l,S[l]},{l,GaloisGroup[n]}],#[[2]]&]])[[All,1]];
And@@(NonNegative[#]\[And]IntegerQ[#]&/@Flatten[Table[Sum[(S[x][[w]]S[y][[w]]AlgebraicConjugate[S[z][[w]]])/S[1][[w]],{w,1,Length[dimensions[[2]]]}],{x,galoisElements},{y,galoisElements},{z,galoisElements}]])
]


GaloisOrbitClumps[n_,dimension_]:=GaloisOrbitClumps[n,dimension]=Module[{clumps},
clumps=Union[#~Join~(-#)]&/@Outer[GaloisAction[n][#2][#1/dimension[[1]]]dimension[[1]]&,dimension[[2]],GaloisGroup[n]];
Sort[Flatten[Position[clumps,#]]&/@Union[clumps]]
]


GaloisOrbitClumps[induction_]:=GaloisOrbitClumps@@DimensionsFromInductionMatrix[induction]


(* TODO this could be tightened in many ways *)


Clear[PossibleConductors]


PossibleConductors[inductionMatrix_]:=PossibleConductors[inductionMatrix]=Module[{rank,inductionsFromOne,dimensions,\[ScriptCapitalD],n,primes,powers,l=3,largestClump},
dimensions=DimensionsFromInductionMatrix[inductionMatrix][[2,2]];
(*Print[dimensions];*)
rank=Length[dimensions];
inductionsFromOne=Count[inductionMatrix[[1]],Except[0]];
largestClump=Max@@(Length/@GaloisOrbitClumps[inductionMatrix]);
\[ScriptCapitalD]=Sum[d^2,{d,dimensions}];
n=identify\[Zeta][\[ScriptCapitalD][[1]]];
primes=FactorInteger[AlgebraicNumberNorm[\[ScriptCapitalD]]][[All,1]];
sizeOfOrbit[p_,k_]:=p^(k-1) (p-1)/2;
sizeOfOrbit[2,k_]:=Max[1,2^(k-3)];
powers=Table[\[Infinity],{Length[primes]}];
While[(Max@@powers)>=l,
l++;
powers=Cases[Tuples[Table[Range[l],{Length[primes]}]],t_/;(Max@@Table[sizeOfOrbit[primes[[i]],t[[i]]],{i,1,Length[primes]}]<=largestClump)\[And](Sum[sizeOfOrbit[primes[[i]],t[[i]]],{i,1,Length[primes]}]<=rank-inductionsFromOne)];
];
Times@@(primes^#)&/@powers
]


Clear[PossibleGaloisImages,PossibleGaloisImagesWithSigns];


PossibleGaloisImages[n_,dimensions_,1]:=Table[{i},{i,1,Length[dimensions[[2]]]}];
PossibleGaloisImages[n_,dimensions_,l_]:=PossibleGaloisImages[n,dimensions,l]=Module[{images},
images=GaloisAction[n][l][#/dimensions[[1]]]dimensions[[1]]&/@dimensions[[2]];
Flatten[Position[dimensions[[2]],#|(-#),1]]&/@images
]
PossibleGaloisImages[n_,dimensions_]:=Table[l->PossibleGaloisImages[n,dimensions,l],{l,GaloisGroup[n]}]


PossibleGaloisImagesWithSigns[n_,dimensions_,1]:=Table[{i},{i,1,Length[dimensions[[2]]]}];
PossibleGaloisImagesWithSigns[n_,dimensions_,l_]:=PossibleGaloisImagesWithSigns[n,dimensions,l]=Module[{images},
images=GaloisAction[n][l][#/dimensions[[1]]]dimensions[[1]]&/@dimensions[[2]];
Flatten[Position[dimensions[[2]],#,1]~Join~(-Position[dimensions[[2]],-#,1])]&/@images
]


PossibleGaloisImages[n_Integer,dimensions_List,eigenvalues_List,1]:=Table[{i},{i,1,Length[dimensions[[2]]]}]
PossibleGaloisImages[n_Integer,dimensions_List,eigenvalues_List,l_Integer]:=PossibleGaloisImages[n,dimensions,eigenvalues,l]=Module[{images},
images={GaloisAction[n][l][#[[1]]/dimensions[[1]]]dimensions[[1]],Mod[l^2 #[[2]],1]}&/@Transpose[{dimensions[[2]],eigenvalues}];
Flatten[Position[Transpose[{dimensions[[2]],eigenvalues}],{#[[1]]|(-#[[1]]),#[[2]]},1]]&/@images
]


Clear[PossibleGaloisTraces]


possibleSums[sequence_List]:=Fold[Union[Flatten[Outer[Plus,#1,#2,1]]]&,{0},sequence]


PossibleGaloisTraces[n_,dimensions_,l_]:=PossibleGaloisTraces[n,dimensions,l]=Module[{images,contributions},
images=Transpose[{Range[Length[dimensions[[2]]]],PossibleGaloisImagesWithSigns[n,dimensions,l]}];
contributions[{k_,i_}]/;MemberQ[i,k]\[And]Length[i]>1:={1,0};
contributions[{k_,i_}]/;MemberQ[i,-k]\[And]Length[i]>1:={-1,0};
contributions[{k_,i_}]/;MemberQ[i,k]\[And]Length[i]==1:={1};
contributions[{k_,i_}]/;MemberQ[i,-k]\[And]Length[i]==1:={-1};
contributions[{k_,i_}]/;!MemberQ[i,k]\[And]!MemberQ[i,-k]:={0};
possibleSums[contributions/@images]
]
PossibleGaloisTraces[n_,dimensions_]:=Table[l->PossibleGaloisTraces[n,dimensions,l],{l,GaloisGroup[n]}]


MaximumGaloisFixedPoints[n_,dimensions_,l_]:=MaximumGaloisFixedPoints[n,dimensions,l]=With[{\[ScriptCapitalD]=dimensions[[1]]},Count[dimensions[[2]],d_/;With[{ga=GaloisAction[n][l][d/\[ScriptCapitalD]]\[ScriptCapitalD]},ga==d||ga==-d]]]
MaximumGaloisFixedPoints[n_,dimensions_]:=Table[l->MaximumGaloisFixedPoints[n,dimensions,l],{l,GaloisGroup[n]}]


RepresentationSign[q_,k_Integer]/;PrimePowerQ[q]:=RepresentationSign[q,k]=Sign[CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[k,ConjugacyClassOf[q][{{-1,0},{0,-1}}]]]]
RepresentationSign[n_,ts:{__Integer}]:=Product[RepresentationSign[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],ts}]}]


totalModOne[x___]:=Mod[Total[{x}],1]


TEigenvalues[N_,t:{__Integer}]:=TEigenvalues[N,t]=Module[{primePowers=#[[1]]^#[[2]]&/@FactorInteger[N]},
Flatten[Outer[totalModOne,Sequence@@Table[TEigenvalues[primePowers[[i]],t[[i]]],{i,1,Length[primePowers]}]]]
]
TEigenvalues[N_,ts:{{__Integer}...}]:=TEigenvalues[N,#]&/@ts


(* Given \[Chi] = ( tr(M^r) )_{r=0}^{n-1}, this lists all the eigenvalues of M which are n-th roots of unity. *)
NewtonsIdentity[n_,\[Chi]_]:=Join@@Table[Table[m/n,{RootReduce[1/n \[Chi].Table[\[Zeta][n]^(-m l),{l,0,n-1}]]}],{m,0,n-1}]


TEigenvalues[q_,k_Integer]/;PrimePowerQ[q]:=TEigenvalues[q,k]=Module[{\[Chi]},
lastTEigenvalues={q,k};
\[Chi]=liftCyclotomicNumber[q]/@Table[CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[k,l]],{l,ConjugacyClassesOfPowersOfT[q]}];
NewtonsIdentity[q,\[Chi]]
]


liftCyclotomicNumber[N_][x:(_Integer|_Rational)]:=x
liftCyclotomicNumber[N_][a_AlgebraicNumber]:=liftCyclotomicNumber[N][a]=With[{n=LCM[N,identify\[Zeta][a[[1]]]]},
AlgebraicNumberPolynomial[a,\[Zeta][n]^(n/identify\[Zeta][a[[1]]])]
]


SaveTEigenvalues[]:=AbortProtect[Put[DownValues[TEigenvalues],FileNameJoin[{dataDirectory,"tEigenvalues.m"}]]]
LoadTEigenvalues[]:=(DownValues[TEigenvalues]=Get[FileNameJoin[{dataDirectory,"tEigenvalues.m"}]]~Join~DownValues[TEigenvalues];)


RepresentationConductor[N_,{}]:=1
RepresentationConductor[N_,t:{__Integer}]:=RepresentationConductor[N,t]=LCM@@(Denominator/@TEigenvalues[N,t])
RepresentationConductor[N_,ts:{{__Integer}...}]:=LCM@@(RepresentationConductor[N,#]&/@ts)


RepresentationDimension[q_,t_Integer]/;PrimePowerQ[q]:=RepresentationDimension[q,t]=CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[t,1]]
RepresentationDimension[n_,t:{__Integer}]:=Product[RepresentationDimension[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],t}]}]
RepresentationDimension[n_,ts:{{__Integer}...}]:=Sum[RepresentationDimension[n,t],{t,ts}]


addMaps[m1_,m2_]:=Module[{keys},
keys=Union[m1[[All,1]]~Join~m2[[All,1]]];
#->Replace[#,m1~Join~{_->0}]+Replace[#,m2~Join~{_->0}]&/@keys
]


$RecursionLimit=4000;


RepresentationsForRankDirty={};


RepresentationsForRank[n_,r_]:=RepresentationsForRank[n,r]=Module[{characterTables,tuples,PartialRepresentation,addRepresentation,addRepresentations,representations,factors,trivial},
Print["Enumerating allowed representation types for conductor ",n, " and rank " ,r,"."];
characterTables=CharacterTable[GAP[SL[2,Subscript[Z, #]]]]&/@PrimePowers[n];
(*characterTables0=characterTables;*)
tuples=Cases[Flatten[Outer[List,Sequence@@ Range[Length/@characterTables]],Length[PrimePowers[n]]-1],t_/;RepresentationDimension[n,t]<=r];
(*tuples0=tuples;*)
tuples=SortBy[Normal[GroupBy[tuples,RepresentationConductor[n,#]&]],Function[p,{!Divisible[p[[1]],#]&/@Reverse[PrimePowers[n]],-p[[1]]}]];
(*tuples0=tuples;*)
tuples=#[[1]]->SortBy[#[[2]],Function[ts,{!MemberQ[TEigenvalues[n,ts],0],-RepresentationSign[n,ts]}]]&/@tuples;
(*tuples0=tuples;*)
addRepresentation[{},conductor_Integer][pr_PartialRepresentation]:={pr};
addRepresentation[{t:{__Integer},others___},conductor_Integer][pr:PartialRepresentation[ts:{{__Integer}...},remainingDimension_Integer,open_List,signedMultiplicities_List]]:=Module[{max,min},
(*pr0=Take[pr,2];*)
max=Floor[remainingDimension/RepresentationDimension[n,t]];
(* check that either this representation has 1, or all eigenvalues have appeared previously *)
max=Min[max,If[MemberQ[TEigenvalues[n,t],0]\[Or]Length[Complement[TEigenvalues[n,t],open]]==0,\[Infinity],0]];If[!MemberQ[TEigenvalues[n,t],0]\[And]Negative[RepresentationSign[n,t]],
(* look at the signed multiplicities *)
min=Min@@(Replace[#[[1]],signedMultiplicities~Join~{_->0}]/#[[2]]&/@Tally[TEigenvalues[n,t]]);
max=Min[max,min];
];
Join@@(addRepresentation[{others},conductor]/@Table[
If[k==0,
pr,
PartialRepresentation[
ts~Join~Table[t,{k}],
remainingDimension-k RepresentationDimension[n,t],
If[
MemberQ[TEigenvalues[n,t],0],
Union[open,TEigenvalues[n,t]],
open
],
addMaps[signedMultiplicities,Rule@@({1,k RepresentationSign[n,t]}#)&/@Tally[TEigenvalues[n,t]]]
]
],{k,0,max}])
];
addRepresentations[{}][pr_PartialRepresentation]:={pr};
addRepresentations[{conductor_Integer->(ts:{{__Integer}...}),others___}][pr_PartialRepresentation]:=Module[{result},
result=addRepresentation[ts,conductor][pr];
(*Print[Length[result]];*)
(* if the conductor is a prime power, make sure that by now we've actually used something with large enough conductor *)
If[MemberQ[PrimePowers[n],conductor],
(*Print[RepresentationConductor[n,#]&/@result\[LeftDoubleBracket]All,1\[RightDoubleBracket]];*)
result=Cases[result,PartialRepresentation[Ts:{{__Integer}...},___]/;Divisible[RepresentationConductor[n,Ts],conductor]];
];
(*Print[Length[result]];*)
Join@@(addRepresentations[{others}]/@result)
];
representations=addRepresentations[Most[tuples]][PartialRepresentation[{},r-1,{},{}]][[All,1]];
trivial=tuples[[-1,2,1]];
representations=Map[{#,RepresentationDimension[n,#]}&,representations,{2}];
representations=#~Join~Table[{trivial,1},{r-Total[#[[All,2]]]}]&/@representations;
representations={#,TEigenvalues[n,#[[All,1]]]}&/@representations;
representations=Cases[representations,{V_,Ts_}/;And@@Table[(RepresentationSign[n,#]&/@(V[[All,1]])).(Count[#,t]&/@Ts)>=0,{t,Union[Flatten[Ts]]}]];
RepresentationsForRankDirty=Union[RepresentationsForRankDirty,{n}];
Print["Found ",Length[representations]," allowed representation types for conductor ",n, " and rank " ,r,"."];
representations
]


RepresentationsForDimensions[N_,dimensions:{\[ScriptCapitalD]_?NumericQ,{__?NumericQ}}]:=RepresentationsForDimensions[N,dimensions]=Cases[RepresentationsForRank[N,Length[dimensions[[2]]]],{V_,_}/;
And@@Table[MemberQ[PossibleGaloisTraces[N,dimensions,l],TraceOfGalois[N,V[[All,1]],l]],{l,GaloisGroup[N]}]]


RepresentationsForInductionMatrix[N_,inductionMatrix:{{__Integer}..}]:=Module[{dimensions,numberOfObjectsInInductionOfOne,result},
dimensions=DimensionsFromInductionMatrix[N,inductionMatrix];
numberOfObjectsInInductionOfOne=Count[inductionMatrix[[1]],Except[0]];
result=Cases[RepresentationsForDimensions[N,dimensions],{V_,Ts_}/;Count[Flatten[Ts],0]>=numberOfObjectsInInductionOfOne];
Print["Found ",Length[result]," allowed representation types for conductor ",N, " and induction matrix " ,MatrixForm[inductionMatrix],"."];
result
]


RepresentationsForRankProgress[]:=SortBy[(#[[1]]->Max@@(#[[2,All,2]]))&/@Normal[GroupBy[Cases[DownValues[RepresentationsForRank],(p_:>_)/;IntegerQ[p[[1,2]]]:>{p[[1,1]],p[[1,2]]}],#[[1]]&]],#[[2]]&]


SaveRepresentationsForRank[]:=SaveRepresentationsForRank/@RepresentationsForRankDirty;
LoadRepresentationsForRank[]:=Module[{data},
LoadRepresentationsForRank/@Flatten[StringCases[#,___~~"-"~~(n:(DigitCharacter..))~~".m.gz":>ToExpression[n]]&/@FileNames[FileNameJoin[{dataDirectory,"representationsForRank-*.m.gz"}]]];
]


SaveRepresentationsForRank[n_Integer]:=Module[{data,outputDirectory,timing},
If[!MemberQ[RepresentationsForRankLoaded,n],LoadRepresentationsForRank[n]];
data=Cases[DownValues[RepresentationsForRank],((p_:>v_)/;p[[1,1]]===n\[And]IntegerQ[p[[1,2]]]):>({p[[1,1]],p[[1,2]]}->v[[All,1,All,1]])];
If[Length[data]==0,
Print["Nothing to do."],
Print["Exporting data for conductor ",n,". Raw bytes: ",ByteCount[data]];
outputDirectory=FileNameJoin[{dataDirectory,"representationsForRank"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
timing=AbsoluteTiming[
GZIP[data,FileNameJoin[{outputDirectory,"representationsForRank-"<>ToString[n]<>".m.gz"}]]
][[1]];
Print["... completed in ",timing, " seconds."];
RepresentationsForRankDirty=DeleteCases[RepresentationsForRankDirty,n];
]
];
LoadRepresentationsForRank[n_Integer]:=Module[{file,data},
file=FileNameJoin[{dataDirectory,"representationsForRank","representationsForRank-"<>ToString[n]<>".m.gz"}];
If[FileExistsQ[file],
data=ImportGZIP[file];
Cases[data,({n,k_}->Vs_):>(RepresentationsForRank[n,k]=(Function[ts,{{#,RepresentationDimension[n,#]}&/@ts,TEigenvalues[n,#]&/@ts}]/@Vs))];
];
RepresentationsForRankLoaded=Union[RepresentationsForRankLoaded,{n}];
]


RepresentationsForRankLoaded={};


SaveAll[]:=(SaveRepresentationsForRank[];SaveTEigenvalues[];SaveConjugacyClasses[];SaveCharacterTables[];
SaveGenerators[];)


workOnRepresentations[conductors_,rank_:\[Infinity]]:=Module[{status,min,i,timing,length,counter=0},
status={#,0.0,0,0}&/@conductors;
While[(Min@@status[[All,3]])<rank,
min=Min@@(status[[All,2]]+10.^-4 status[[All,4]]);
i=Position[status,{_,m_,_,l_}/;m+10.^-4 l<=min+10.^-6][[1,1]];
Print["Running RepresentationsForRank[",status[[i,1]],",",status[[i,3]]+1, "] ..."];
{timing,length}=AbsoluteTiming[Length[RepresentationsForRank[status[[i,1]],status[[i,3]]+1]]];
Print["Took ",timing," seconds."];
Print["Found ",length," decompositions."];
status[[i]]={status[[i,1]],timing,status[[i,3]]+1,length};
status=DeleteCases[status,{_,_,rank,_}];
];
Print["Finished ... saving results."];
SaveRepresentationsForRank/@conductors;
]


LiftsOf1[inductionMatrix_]:=Flatten[Position[Transpose[inductionMatrix],{Except[0],___},1]]


ListDifference[{a___,b_,c___},{b_,d___}]:=ListDifference[{a,c},{d}]
ListDifference[L_,{}]:=L


AllocateEigenvaluesToGaloisOrbitClumps[n_Integer,inductionMatrix_]:=Module[{outputDirectory,filename,liftsOf1,result,EigenvalueClumps,allocations,AllocateEigenvaluesToGaloisOrbitClumpsImpl,AllocateEigenvaluesToGaloisOrbitClumpsImpl0},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToGaloisOrbitClumps"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>SHA1[inductionMatrix]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
Print["Allocating T-eigenvalues to Galois orbit clumps for ",MatrixForm[inductionMatrix]];
AllocateEigenvaluesToGaloisOrbitClumpsImpl0[X___]:=AllocateEigenvaluesToGaloisOrbitClumpsImpl0[X]=AllocateEigenvaluesToGaloisOrbitClumpsImpl[X];
AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations_,{}]:={allocations};
AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations_,{{eigenvalues_,0,minimumAllowedClump_:1},otherEigenvalues___}]:=AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations,{otherEigenvalues}];
AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations_,{{eigenvalues_,multiplicity_,minimumAllowedClump_:1},otherEigenvalues___}]:=Module[{positions},
(* decide which clumps have enough room *)
positions=Cases[Flatten[Position[allocations,{simples_,allocatedEigenvalues_}/;(Length[simples]-Length[allocatedEigenvalues]-Max[(Count[simples,Alternatives@@liftsOf1]-Count[allocatedEigenvalues,0]-Count[eigenvalues,0]),0]>=Length[eigenvalues]),1]],p_/;p>=minimumAllowedClump];
Join@@(Function[{p},AllocateEigenvaluesToGaloisOrbitClumpsImpl[ReplacePart[allocations,p->ReplacePart[allocations[[p]],2->allocations[[p,2]]~Join~eigenvalues]],{{eigenvalues,multiplicity-1,p},otherEigenvalues}]]/@positions)
];
EigenvalueClumps[{}]:={};
EigenvalueClumps[eigenvalues:{__?NumericQ}]:=EigenvalueClumps[eigenvalues]=Module[{clump},
clump=Union[Table[Mod[l^2 eigenvalues[[1]],1],{l,GaloisGroup[n]}]];
{clump}~Join~EigenvalueClumps[ListDifference[eigenvalues,clump]]
];
EigenvalueClumps[eigenvalueLists:{{__?NumericQ}..}]:=Join@@(EigenvalueClumps[#]&/@eigenvalueLists);

liftsOf1=LiftsOf1[inductionMatrix];
allocations=RepresentationsForInductionMatrix[n,inductionMatrix];
result=Join@@Map[Function[representation,representation~Join~{#}&/@AllocateEigenvaluesToGaloisOrbitClumpsImpl0[{#,{}}&/@GaloisOrbitClumps[n,DimensionsFromInductionMatrix[n,inductionMatrix]],Tally[EigenvalueClumps[representation[[2]]]]]],allocations];
GZIP[result,filename];
Print["Found ",Length[result], " ways to allocate T-eigenvalues to the Galois orbit clumps for ",MatrixForm[inductionMatrix]];
result
]
]


EquivalenceClassesOfSimples[inductionMatrix_]:=EquivalenceClassesOfSimples[inductionMatrix]=Normal[GroupBy[Range[Length[inductionMatrix[[1]]]],inductionMatrix[[All,#]]&]][[All,2]]


EquivalenceClassesOfSimples[induction_,eigenvalues_]:=Normal[GroupBy[Range[Length[induction[[1]]]],{induction[[All,#1]],eigenvalues[[#1]]}&]][[All,2]]


(*Clear[AllocateEigenvaluesToSimples]*)


AllocateEigenvaluesToSimples[n_,inductionMatrix_,clumps_]:=(*AllocateEigenvaluesToSimples[n,inductionMatrix,clumps]=*)
Module[{toAssign,result},
toAssign=SortBy[EquivalenceClassesOfSimples[inductionMatrix],Function[class,{-Length[Intersection[class,LiftsOf1[inductionMatrix]]],-DimensionsFromInductionMatrix[n,inductionMatrix][[2,class[[1]]]]}]];
result=AllocateEigenvaluesToSimples[n,inductionMatrix,clumps,toAssign,{},Chop[N[-DimensionsFromInductionMatrix[n,inductionMatrix][[1]]]],Chop[N[DimensionsFromInductionMatrix[n,inductionMatrix][[1]]^2]]];
Cases[result,r_/;And@@Table[Min@@(Length/@PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,inductionMatrix],r,l])>=1,{l,GaloisGroupGenerators[n]}]]
]


AllocateEigenvaluesToSimples[n_,inductionMatrix_,clumps_,{},assigned_,_,_]:=
Module[{t,T,\[ScriptCapitalD],d},
(* now we check the top left entry of STS=TST exactly *)
t=Sort[assigned][[All,2]];
T=\[Zeta][n]^(n t);
(*counter++;*)
{\[ScriptCapitalD],d}=DimensionsFromInductionMatrix[n,inductionMatrix];
If[(d^2).T-\[ScriptCapitalD]==0,
{t},{}
]
]


AllocateEigenvaluesToSimples[n_,inductionMatrix_,clumps_,{toAssign_,others___},assigned_,partialSum_,totalRemainingDimension_]:=Module[{i,subsets,dims},
If[Abs[N[partialSum]]>=totalRemainingDimension+1,
(*stoppedEarly++;*)
{},
dims=DimensionsFromInductionMatrix[n,inductionMatrix][[2,toAssign]];
i=Position[clumps,{simples_,_}/;Length[Intersection[simples,toAssign]]==Length[toAssign],1][[1,1]];
subsets=
If[Length[Intersection[LiftsOf1[inductionMatrix],toAssign]]>0,
{Table[0,{Length[toAssign]}]},
Union[Subsets[clumps[[i,2]],{Length[toAssign]}]]
];
(* we could try to filter the subsets early, checking compatibility with possible Galois actions. *)
(* for now, we just check after all have been allocated *)
Join@@(Function[subset,AllocateEigenvaluesToSimples[n,inductionMatrix,ReplacePart[clumps,i->{ListDifference[clumps[[i,1]],toAssign],ListDifference[clumps[[i,2]],subset]}],{others},assigned~Join~Thread[toAssign->subset],partialSum+(dims^2).(\[Zeta][n]^(n subset)),Chop[totalRemainingDimension-dims.dims]]]/@subsets)
]
]


AllocateEigenvaluesToSimples[n_,inductionMatrix_]:=Module[{outputDirectory,filename,result},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToSimples"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>SHA1[inductionMatrix]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
result=Join@@(Map[Function[A,{A[[1]],#}&/@AllocateEigenvaluesToSimples[n,inductionMatrix,A[[3]]]],AllocateEigenvaluesToGaloisOrbitClumps[n,inductionMatrix]]);
GZIP[result,filename];
Print["Found ",Length[result], " candidate T-matrices for ",MatrixForm[inductionMatrix]];
Print[TableForm[#]]&/@result;
result]
]


FrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_]:=Module[{dims,\[ScriptCapitalD]},
{\[ScriptCapitalD],dims}=DimensionsFromInductionMatrix[n,inductionMatrix];
Table[
1/\[ScriptCapitalD] \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 1\), \(Length[inductionMatrix[[1]]]\)]\(
\*SuperscriptBox[\(\[Zeta][n]\), \(\((n\ Ts[[j]])\) k\)] dims[[j]] inductionMatrix[[m, j]]\)\),
{m,1,Length[inductionMatrix]}]
]


AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators1[n_,fusion_,inductionMatrix_]:=Cases[
AllocateEigenvaluesToSimples[n,inductionMatrix], 
a_/;FrobeniusSchurIndicators[n,fusion,inductionMatrix][a[[2]]][1]==UnitVector[Length[inductionMatrix],1]
]


FusionPower[fusion_][i_ (* i-th object *),k_ (* raised to the k-th power *)]:=MatrixPower[fusion[[2,1,2,i]],k].UnitVector[Length[fusion[[2,1,2]]],1]


FrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_,l_]/;GCD[k,l]==1:=GaloisAction[k][l]/@ToNumberField[FrobeniusSchurIndicators[n,fusion,inductionMatrix][Ts][k],\[Zeta][k]]
FrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_,l_]:=Module[{g=GCD[k,l]},
Table[
FusionPower[fusion][m,g].FrobeniusSchurIndicators[n,fusion,inductionMatrix][Ts][k/g,l/g]
,{m,1,Length[inductionMatrix]}]
]


VerifyFrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_]:=Table[
{Length[NewtonsIdentity[k,Table[FrobeniusSchurIndicators[n,fusion, inductionMatrix][Ts][k,l][[m]],{l,0,k-1}]]],FusionPower[fusion][m,k][[1]]}
,
{m,1,Length[inductionMatrix]}]


AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators[n_,fusion_,k0_,inductionMatrix_]:=Module[{outputDirectory,filename,result,allocated},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>ToString[k0]<>","<>SHA1[{fusion,inductionMatrix}]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
Print["Looking for T-matrices for ",DisplayGraph[fusion], " ",MatrixForm[inductionMatrix]];
allocated=AllocateEigenvaluesToSimples[n,inductionMatrix];
Print["... checking Frobenius-Schur indicators"];
result=Module[{pairs,cachedFrobeniusSchurIndicators,verifyFrobeniusSchurIndicators},
cachedFrobeniusSchurIndicators[Ts_][X___]:=cachedFrobeniusSchurIndicators[Ts][X]=FrobeniusSchurIndicators[n,fusion,inductionMatrix][Ts][X];
verifyFrobeniusSchurIndicators[Ts_][k_]:=verifyFrobeniusSchurIndicators[Ts][k]=Table[
{Length[NewtonsIdentity[k,Table[cachedFrobeniusSchurIndicators[Ts][k,l][[m]],{l,0,k-1}]]],FusionPower[fusion][m,k][[1]]}
,
{m,1,Length[inductionMatrix]}];

(*Print[AllocateEigenvaluesToSimples[n,inductionMatrix]];*)
(*Print[cachedFrobeniusSchurIndicators[#\[LeftDoubleBracket]2\[RightDoubleBracket]][1]&/@AllocateEigenvaluesToSimples[n,inductionMatrix]];*)
pairs=Map[{#,Table[verifyFrobeniusSchurIndicators[#[[2]]][k],{k,1,k0}]}&,
Cases[
allocated, 
a_/;cachedFrobeniusSchurIndicators[a[[2]]][1]==UnitVector[Length[inductionMatrix],1]
]
];
(*Print[pairs];*)
Cases[pairs,{x_,v_}/;Union[#.{1,-1}&/@Flatten[v,1]]==={0}:>x]
];
GZIP[result,filename];
Print["Found ",Length[result], " T-matrices with good Frobenius-Schur indicators for ",DisplayGraph[fusion], " ",MatrixForm[inductionMatrix]];
Print[TableForm[#]]&/@result;
result]
]


(*Progress[fusion_,induction_]:=FileNames[ToFileName[{dataDirectory,"*","*"<>SHA1[induction]<>"*"}]]~Join~FileNames[ToFileName[{dataDirectory,"*","*"<>SHA1[{fusion,induction}]<>"*"}]]*)


(*StillTodo[fusion_,induction_]:=Complement[PossibleConductors[induction],ToExpression[StringSplit[StringSplit[#,"/"]\[LeftDoubleBracket]-1\[RightDoubleBracket],","]\[LeftDoubleBracket]1\[RightDoubleBracket]]&/@Cases[Progress[fusion,induction],s_/;!StringFreeQ[s,"allocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators"]]]*)


Clear[PartialGaloisAction]


PartialGaloisAction[n_Integer,induction_?MatrixQ]:=PartialGaloisAction[Table[l->PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,induction],l],{l,GaloisGroup[n]}],EquivalenceClassesOfSimples[induction]]
PartialGaloisAction[n_Integer,induction_?MatrixQ,eigenvalues_List]:=PartialGaloisAction[Table[l->PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,induction],eigenvalues,l],{l,GaloisGroup[n]}],EquivalenceClassesOfSimples[induction,eigenvalues]]


SplitSymmetries[pga_PartialGaloisAction,ks:{__Integer}]:=ReplacePart[pga,2->SortBy[DeleteCases[Flatten[{Intersection[#,ks],Complement[#,ks]}&/@pga[[2]],1],{}],#[[1]]&]]


Clear[RefinePartialGaloisAction]


RefinePartialGaloisAction[n_,pga_PartialGaloisAction]:=Module[{targets,l,k},
(* look for a Galois element which isn't determined yet. *)
targets=Position[pga[[1]],images_/;Length[images]>1,{3}];
targets=SortBy[targets,!MemberQ[GaloisGroupGenerators[n],GaloisGroup[n][[#[[1]]]]]&];
If[Length[targets]==0,
(* we're done! *)
{GaloisAction[pga[[1]]/.list:{{_Integer}..}:>Flatten[list],pga[[2]]]},
l=GaloisGroup[n][[targets[[1,1]]]];
k=targets[[1,3]];
lastPartialGaloisAction=RefinePartialGaloisAction[n,SplitSymmetries[pga,{k}],l,k]
]
]


RefinePartialGaloisAction[n_,pga_PartialGaloisAction,l_Integer,k_Integer]:=Module[{images},
(* okay, decide where l sends k *)
images=(l/.pga[[1]])[[k]];
(* make use of symmetries: *)
images=DeleteCases[Intersection[images,#]&/@pga[[2]],{}][[All,1]];
Join@@(RefinePartialGaloisAction[n,SplitSymmetries[pga,{#}],l,k,{#}]&/@images)
]


RefinePartialGaloisAction[n_,pga_PartialGaloisAction,l_Integer,k_Integer,ms0:{}]:={}


RefinePartialGaloisAction[n_,pga_PartialGaloisAction,l_Integer,k_Integer,ms0:{__Integer}]:=Module[{ms,result,updateResult,rank},
If[Length[Complement[(l/.pga[[1]])[[k]],ms0]]==0,
(* No new information *)
{pga},
ms=Intersection[ms0,(l/.pga[[1]])[[k]]];
If[Length[ms]==0,
{},
result=pga/.(l->images_):>(l->ReplacePart[If[Length[ms]==1,Complement[#,ms]&/@images,images],k->ms]);
(* And now we should propagate information to all other Galois elements *)
result=EnforcePartialGaloisActionInverses[n,result,l,k];
rank=Length[pga[[1,1,2]]];
(*result=Fold[EnforcePartialGaloisActionConsistency[n,#1,#2\[LeftDoubleBracket]1\[RightDoubleBracket],l,#2\[LeftDoubleBracket]2\[RightDoubleBracket]]&,{result},Flatten[Outer[List,GaloisGroup[n],Range[rank]],1]];*)
updateResult[r_]:=Fold[EnforcePartialGaloisActionConsistency[n,#1,#2,l,k]&,r,GaloisGroup[n]];
result=FixedPoint[updateResult,result];
result
]
]
]


(* if we know a(k) exactly, we know a^{-1}(a(k)) *)
EnforcePartialGaloisActionInverses[n_,pgas_List,a_Integer,k_Integer]:=Join@@(EnforcePartialGaloisActionInverses[n,#,a,k]&/@pgas)
EnforcePartialGaloisActionInverses[n_,pga_PartialGaloisAction,a_Integer,k_Integer]:=Module[{},
If[Length[(a/.pga[[1]])[[k]]]==1,
RefinePartialGaloisAction[n,pga,GaloisInverse[n][a],(a/.pga[[1]])[[k,1]],{k}],
{pga}
]
]
(* (ab)(k) must be a subset of a(b(k)) *)EnforcePartialGaloisActionConsistency[n_,pgas_List,a_Integer,b_Integer,k_Integer]:=Join@@(EnforcePartialGaloisActionConsistency[n,#,a,b,k]&/@pgas)
EnforcePartialGaloisActionConsistency[n_,pga_PartialGaloisAction,a_Integer,b_Integer,k_Integer]:=Module[{targets},
targets=Intersection[
Union[Flatten[(a/.pga[[1]])[[#]]&/@((b/.pga[[1]])[[k]])]],
Union[Flatten[(b/.pga[[1]])[[#]]&/@((a/.pga[[1]])[[k]])]]
];
RefinePartialGaloisAction[n,pga,Mod[a b,n],k,targets]
]


Clear[CompletePartialGaloisAction]


CompletePartialGaloisAction[n_,pga_PartialGaloisAction]:=Module[{f},
f[p_PartialGaloisAction]:=f/@RefinePartialGaloisAction[n,p];
f[ga_GaloisAction]:={ga};
Flatten[f[pga]]
]


mkString[x_List,sep_]:=StringJoin@@(ToString/@Most[Flatten[Transpose[{x,Table[sep,{Length[x]}]}]]])


DreadnautPath="~/bin/dreadnaut";


NautyHash[ga_GaloisAction]:=Module[{G,X,preamble,edges,partition,cmd,return},
G=Length[ga[[1]]];
X=Length[1/.ga[[1]]];
preamble="c\nn="<>ToString[(G+2)X]<>" g\n";
edges=(StringJoin@@Table[(StringJoin@@Table[ToString[x+(g+1)X]<>" ",{g,0,G-1}])<>";\n",{x,0,X-1}])<>
(StringJoin@@Table[ToString[x]<>" "<>(StringJoin@@Table[ToString[(ga[[1,g+1,1]]/.ga[[1]])[[x+1]]-1+(g+1)X]<>" ",{g,0,G-1}])<>";\n",{x,0,X-1}])<>".\n";
partition="f=["<>mkString[mkString[#,","]&/@ga[[2]],"|"]<>"]\n";
cmd="x z\n";
return=Run[DreadnautPath<>" <<STOP > /tmp/dreadnaut"<>ToString[$KernelID]<>".out\n"<>preamble<>edges<>partition<>cmd<>"STOP"];
If[return!=0,
Print["Something went wrong while running dreadnaut. Please check you have a copy of dreadnaut, and modify FusionAtlas`ModularData`Private`DreadnautPath if necessary."];
];
"["<>StringJoin@@(StringSplit[StringSplit[Import["/tmp/dreadnaut"<>ToString[$KernelID]<>".out"],"\n"][[-1]]," "][[{2,3}]])
]


CompleteGaloisActions[n_,induction_]:=CompleteGaloisActions[n,induction]=Module[{outputDirectory,filename,result},
outputDirectory=FileNameJoin[{dataDirectory,"completeGaloisActions"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>SHA1[induction]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
result=Normal[GroupBy[CompletePartialGaloisAction[n,PartialGaloisAction[n,induction]],NautyHash]][[All,2,1]];
GZIP[result,filename];
result
]
]
CompleteGaloisActions[n_,induction_,eigenvalues_]:=CompleteGaloisActions[n,induction,eigenvalues]=Normal[GroupBy[CompletePartialGaloisAction[n,PartialGaloisAction[n,induction,eigenvalues]],NautyHash]][[All,2,1]]


AllocateEigenvaluesToSimplesAndCompleteGaloisActions[n_,fusion_,k_,induction_]:=Module[{filename,outputDirectory,result},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToSimplesAndCompleteGaloisActions"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>ToString[k]<>","<>SHA1[{fusion,induction}]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
Print["Computing Galois actions for ",DisplayGraph[fusion]," ",MatrixForm[induction]];
result=Join@@Map[Function[ga,{#,ga}]/@CompleteGaloisActions[n,induction,#[[2]]]&,AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators[n,fusion,k,induction]];
GZIP[result,filename];
Print[" ... finished computing Galois actions."];
result]
]


CalculateGaloisSigns[n_Integer,inductionMatrix_,ga_GaloisAction]:=Module[{S1,dims=DimensionsFromInductionMatrix[n,inductionMatrix],signs},
S1=dims[[2]]/dims[[1]];
signs[l_->permutation_]:=l->(permutation ((GaloisAction[n][l]/@S1)/S1[[permutation]]));
SignedGaloisAction[signs/@ga[[1]]]
]


SignedPermutationMatrix[signedPermutation_]:=IdentityMatrix[Length[signedPermutation]][[Abs[signedPermutation]]]Sign[signedPermutation]


QLinearSolutions[n_Integer,inductionMatrix_][{{Vs_,Ts_},ga_}]:=Module[{Q,q,sga,dims,S1,T,tEquations,modularInvariantEquations,galoisEquations,galoisOnSEquations,C,S2eqCEquations,inductionEquations,equations,Tp,Sp,result},
Q=Table[q[i,j],{i,1,Length[inductionMatrix[[1]]]},{j,1,Length[inductionMatrix[[1]]]}];
Print["Preparing to solve linear equations for the change of basis matrix..."];
Tp=TInRepresentation[n,Vs[[All,1]]];
Sp=SInRepresentation[n,Vs[[All,1]]];
T=DiagonalMatrix[Power[\[Zeta][n],n Ts]];
tEquations={Tp.Q-Q.T};
(*Print["prepared tEquations"];*)
modularInvariantEquations={Sp.Q.inductionMatrix[[1]]-Q.inductionMatrix[[1]]};
(*Print["prepared modularInvariantEquations"];*)
If[ga=!=Null,
sga=CalculateGaloisSigns[n,inductionMatrix,ga];
galoisEquations=Table[GaloisInRepresentation[n,Vs[[All,1]],p[[1]]].Q-Q.SignedPermutationMatrix[p[[2]]],{p,sga[[1]]}];
(*Print["prepared galoisEquations"];*)
dims=DimensionsFromInductionMatrix[n,inductionMatrix];
S1=dims[[2]]/dims[[1]];
galoisOnSEquations=Collect[Table[(Sp.Q)[[All,Abs[p[[2,1]]]]]-(Q.(Sign[p[[2,1]]](GaloisAction[n][p[[1]]]/@S1))),{p,sga[[1]]}],_q];
(*Print["prepared galoisOnSEquations"];*)
(*Print[Flatten[galoisOnSEquations]];*)
C=IdentityMatrix[Length[inductionMatrix[[1]]]][[n-1/.ga[[1]]]];
S2eqCEquations={Sp.Sp.Q-Q.C};,
galoisEquations=galoisOnSEquations=S2eqCEquations={};
];
inductionEquations={Sp.Q.T.Transpose[inductionMatrix]-Q.Inverse[T].Transpose[inductionMatrix]};
equations=Collect[LiftToCommonCyclotomicField[Flatten[tEquations~Join~modularInvariantEquations~Join~galoisEquations~Join~galoisOnSEquations~Join~S2eqCEquations~Join~inductionEquations]],_q];
(*Print["prepared linear equations in Q"];*)
Check[
result=Q/.Solve[equations==0][[1]],
Print["Something went wrong: here are the equations."];
Print[tEquations];
Print[modularInvariantEquations];
Print[galoisEquations];
Print[galoisOnSEquations];
Print[S2eqCEquations];
Abort[];
];
Print["... finished solving linear equations in Q."];
Function[{q0},Evaluate[result/.q->q0]]
]


timesToList[X_Times]:=List@@X
timesToList[X_]:={X}


AlgebraicDegree[eqn_,vars_List]:=Max[Total[GroebnerBasis`DistributedTermsList[eqn/.Equal:>Subtract,vars][[1,All,1]],{2}]]
AlgebraicDegree[eqn_]:=AlgebraicDegree[eqn,Variables[eqn]]


SolveSEquations[n_Integer,inductionMatrix_][Vs_,ga_,Q0_]:=Module[{S,Sp,Q,s,q,dims, S1,C,equations,det,det0,variables,targets,target,\[Alpha],result,solutions},
Sp=SInRepresentation[n,Vs];
S=Table[s[Min[i,j],Max[i,j]],{i,1,Length[inductionMatrix[[1]]]},{j,1,Length[inductionMatrix[[1]]]}];
dims=DimensionsFromInductionMatrix[n,inductionMatrix];
S1=dims[[2]]/dims[[1]];
S[[1]]=S1;
S[[All,1]]=S1;
(*Print[Sp//MatrixForm];*)
(*Print[S//MatrixForm];*)
Q=Q0[q];
(*Print[Q//MatrixForm];*)
det0=Det[Q];
SetAttributes[report,HoldAll];
report[X_]:=Module[{r},Print["factoring determinant ..."];r=X;Print["done!"];r];
det:=(det0=report[Factor[Collect[det0,_q]]]);
variables:=Cases[timesToList[det],(v:q[_,_])^_.:>v];
equations=If[ga===Null,
{Sp.Q-Q.S},
C=IdentityMatrix[Length[inductionMatrix[[1]]]][[n-1/.ga[[1]]]];
{Sp.Q-Q.S,S.S-C}
];
equations=Factor[Collect[LiftToCommonCyclotomicField[Flatten[equations]],_q|_s]];
(*Print["found equations"];*)
While[Length[targets=Cases[equations,e_/;AlgebraicDegree[e]==1]~Join~Cases[equations,(Alternatives@@variables)X_:>X]]>0,
(*Print["solving: " ,targets];*)
Solve[targets==0]/.(x_->y_):>(x=y);
equations=Union[DeleteCases[Factor[Collect[equations,_q|_s]],0]];
];
If[Length[variables]>0,
target=SortBy[variables,Count[equations,#,\[Infinity]]&][[-1]];
(*Print["Setting ",target, " to 1"];*)
equations=equations~Join~{target-1};
While[Length[targets=Cases[equations,e_/;AlgebraicDegree[e]==1]~Join~Cases[equations,(Alternatives@@variables)X_:>X]]>0,
(*Print["solving: " ,targets];*)
Solve[targets==0]/.(x_->y_):>(x=y);
equations=Union[DeleteCases[Factor[Collect[equations,_q|_s]],0]];
];
];
Print["S matrix after solving linear equations:"];
Print[(S/.s->Global`s)//MatrixForm];
Print["Q matrix after solving linear equations:"];
Print[(Q/.q->Global`q)//MatrixForm];
(*Print[det/.{s\[Rule]Global`s,q\[Rule]Global`q}];*)
equations=equations~Join~{\[Alpha] det -1};
(*Print[equations/.{s\[Rule]Global`s,q\[Rule]Global`q}];*)
Print["About to start solving quadratic equations..."];
lastSEquations=equations;
solutions=Solve[equations==0];
Print["... done!"];
If[Length[solutions]==0,
Function[{q0,s0},{}],
result=S/.solutions;
Function[{q0,s0},Evaluate[result/.{q->q0,s->s0}]]
]
]


invertibleQ[m_]:=Module[{rules},
rules=(#->RandomInteger[{1000,2000}])&/@Variables[m];
If[Det[m/.rules]!=0,
True,
Factor[Det[m]]=!=0
]
]


FindQLinearSolutions[n_,fusion_,k_,inductionMatrix_,useGalois:(True|False):True]:=Module[{filename,outputDirectory,result,pairs,triples},
outputDirectory=FileNameJoin[{dataDirectory,"findQLinearSolutions"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>ToString[k]<>","<>SHA1[{fusion,inductionMatrix}]<>If[useGalois,"","-no-galois"]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
result=Module[{allocations,q},
allocations=If[useGalois,
AllocateEigenvaluesToSimplesAndCompleteGaloisActions[n,fusion,k,inductionMatrix],
{#,Null}&/@AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators[n,fusion,k,inductionMatrix]
];
pairs=Map[{#,QLinearSolutions[n,inductionMatrix][#]}&,allocations];
triples=Map[{#,invertibleQ[#[[2]][q]]}&,pairs];
Cases[triples,{r_,True}:>r]
];
GZIP[result,filename];
result]
]


FindModularData[n_,fusion_,inductionMatrix_,k:_Integer:6,useGalois:(True|False):True]:=Module[{qsols=FindQLinearSolutions[n,fusion,k,inductionMatrix,useGalois],q,s},
Flatten[Map[(Function[S,{S,#[[1,1,2]]}]/@Union[SolveSEquations[n,inductionMatrix][#[[1,1,1,All,1]],#[[1,2]],#[[2]]][q,s]])&,qsols],1]
]


permuteColumns[inductionMatrix_]:=Transpose[SortBy[Transpose[inductionMatrix],{Total[#],Reverse[#]}&]]


FindModularData[fusion_,induction_?MatrixQ]:=
Module[{},
Print["Beginning calculation of modular data for ",DisplayGraph[fusion]," ",MatrixForm[induction]];
Print["Considering conductors: ",PossibleConductors[induction]];
Join@@Table[FindModularData[n,fusion,permuteColumns[induction],6],{n,PossibleConductors[induction]}]
]
FindModularData[fusion_,inductions:{___?MatrixQ}]:=Join@@(FindModularData[fusion,#]&/@inductions)
FindModularData[fusion_]:=FindModularData[fusion,InductionMatrices[fusion]]
FindModularData[g_GradedBigraph]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(EvenPartFusionRules/@FindFusionRules[g]);
Join@@(FindModularData@@#&/@InductionMatrices[g])
]
FindModularData[ m_?MatrixQ]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(FindFusionRules[m]);
Join@@(FindModularData/@FindFusionRules[m])
]
ParallelFindModularData[fusion_,inductions:{___?MatrixQ}]:=Module[{},
DistributeDefinitions[FindModularData,permuteColumns,PossibleConductors];
Flatten[ParallelTable[FindModularData[n,fusion,permuteColumns[induction],6],{induction,inductions},{n,PossibleConductors[induction]}]]
]
ParallelFindModularData[fusion_]:=ParallelFindModularData[fusion,InductionMatrices[fusion]]
ParallelFindModularData[g_GradedBigraph]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(EvenPartFusionRules/@FindFusionRules[g]);
Join@@(ParallelFindModularData@@#&/@InductionMatrices[g])
]
ParallelFindModularData[ m_?MatrixQ]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(FindFusionRules[m]);
Join@@(ParallelFindModularData/@FindFusionRules[m])
]




End[];


EndPackage[];
