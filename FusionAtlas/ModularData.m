(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
$RecursionLimit=Max[$RecursionLimit,4096];


(* ::Input::Initialization:: *)
BeginPackage["FusionAtlas`ModularData`",{"FusionAtlas`","FusionAtlas`Bigraphs`","FusionAtlas`GraphPairs`","FusionAtlas`TensorSolver`","FusionAtlas`FormalCodegrees`","FusionAtlas`InductionMatrix`","FusionAtlas`DisplayGraphs`"}];


(* ::Input::Initialization:: *)
FindModularData::usage="FindModularData[X_] computes all possible modular data for the centre; the argument X may be a fusion ring and induction matrix, a fusion ring, the rank 3 tensor of fusion multiplicities, a matrix of fusion multiplicities for a single object, or a principal graph.";


(* ::Input::Initialization:: *)
ExplicitGenerators;CharacterTable;ExecuteGAP;GaloisGroup;GaloisAction;GaloisGroupGenerators;PossibleConductors;workOnRepresentations;SInRepresentation;TInRepresentation;DimensionsFromInductionMatrix;GaloisOrbitClumps;PossibleGaloisImages;PossibleGaloisTraces;RepresentationsForRank;RepresentationsForInductionMatrix;SaveRepresentationsForRank;SaveCharacterTables;SaveGenerators;SaveConjugacyClasses;SaveAllModularData;ClearSavedModularData;AllocateEigenvaluesToGaloisOrbitClumps;AllocateEigenvaluesToSimples;AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators;AllocateEigenvaluesToSimplesAndCompleteGaloisActions;FindQLinearSolutions;


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
dataDirectory=FileNameJoin[{FusionAtlasDirectory[],"modularData"}];
If[!FileExistsQ[dataDirectory],CreateDirectory[dataDirectory]];


(* ::Input::Initialization:: *)
GZIP[data_,filename_]/;StringTake[filename,-3]==".gz":=AbortProtect[Module[{},
Put[data,StringDrop[filename, -3]];
Run["cd "<>DirectoryName[filename]<>" && gzip "<>StringDrop[filename, -3]];
]]


(* ::Input::Initialization:: *)
ImportGZIP[filename_]/;StringTake[filename,-3]==".gz":=Module[{unzipped="/tmp/unzipped"<>ToString[$KernelID]<>"-"<>StringDrop[StringDrop[filename, -3],StringLength[DirectoryName[filename]]],result},
Run["cd "<>DirectoryName[filename]<>" && gzip -cd "<>filename<>" > "<>unzipped];
result=Get[unzipped];
DeleteFile[unzipped];
result
]


(* ::Input::Initialization:: *)
SHA1[x_]:=IntegerString[Hash[x,"SHA1"],16,32]


(* ::Input::Initialization:: *)
ClearSavedModularData[fusion_,induction_]:=DeleteFile/@(FileNames[FileNameJoin[{dataDirectory,"*","*"<>SHA1[induction]<>"*"}]]~Join~FileNames[FileNameJoin[{dataDirectory,"*","*"<>SHA1[{fusion,induction}]<>"*"}]])


(* ::Input::Initialization:: *)
GAP[SL[2,Subscript[Z, N_]]]:="Group([[[0,-1],[1,0]],[[1,1],[0,1]]]*One(Integers mod "<>ToString[N]<>"))"


(* ::Input::Initialization:: *)
PossibleGAPPaths:=
Module[{paths},
Run["mdfind -name gap4r8 > /tmp/out"];
Run["locate gap4r8 >> /tmp/out"];
paths=FileNames[#<>"/bin/gap.sh"&/@Flatten[{Import["/tmp/out"]}]];
If[Length[paths]==0,
Print["No copy of GAP was found. Please install gap4r8."];
Abort[]
];
paths
]
GAPPath:=GAPPath=PossibleGAPPaths[[1]];


(* ::Input::Initialization:: *)
ExecuteGAP[cmd_]:=Module[{lines,return},
Print["Calling GAP:"];
Print[cmd];
return=Run["echo '"<>cmd<>"' | "<>GAPPath<>" -x 10000 -o 16g > /tmp/gap"<>ToString[$KernelID]<>"-"<>ToString[$ProcessID]<>".out"];
lines=Import["/tmp/gap"<>ToString[$KernelID]<>"-"<>ToString[$ProcessID]<>".out","Lines",CharacterEncoding->"UTF8"];
    If[StringTake[lines[[1]],11]=!=" ********* "\[And]StringTake[lines[[1]],11]=!=" \:250c\[HorizontalLine]\[HorizontalLine]\[HorizontalLine]\[HorizontalLine]\[HorizontalLine]\[HorizontalLine]\[HorizontalLine]\:2510 "(*\[Or]
(lines\[LeftDoubleBracket]-1\[RightDoubleBracket]=!="gap> "\[And]lines\[LeftDoubleBracket]-1\[RightDoubleBracket]=!="gap> gap> ")*),
Print["It looks like something went wrong running GAP (error code "<>ToString[return]<>"). Please check that you have GAP installed, and modify FusionAtlas`ModularData`Private`GAPPath if necessary."];
Print[cmd];
Print/@lines;
Abort[];
];
lines
]


(* ::Input::Initialization:: *)
(* This uses Vahid Dabbaghian's RepSn package for GAP: http://www.gap-system.org/Packages/repsn.html *)


(* ::Input::Initialization:: *)
ExplicitGenerators[q_][k_]/;PrimePowerQ[q]:=ExplicitGenerators[q][k]=Module[{out,S,T,N,i,Q,invQ},
out=ExecuteGAP["
LoadPackage(\"repsn\");
S:=[[0,-1],[1,0]]*One(Integers mod "<>ToString[q]<>");;
T:=[[1,1],[0,1]]*One(Integers mod "<>ToString[q]<>");;
G:=Group([S,T]);;
rep:=IrreducibleAffordingRepresentation(Irr(G)["<>ToString[k]<>"]);;
Print(\"+++++++\");
S^rep;
Print(\"+++++++\");
T^rep;
Print(\"+++++++\");
"];
{S,T}=(ToExpression/@(StringSplit[(StringJoin@@out),"+++++++"][[{2,3}]]/.s_String:>(StringReplace[s,{"gap> ":>"","[":>"{","]":>"}","E("~~n:(DigitCharacter..)~~")":>"FusionAtlas`\[Zeta]["<>n<>"]"}])));
N=LCM[q,Sequence@@(IdentifyRootOfUnity/@Union[Cases[{S,T},a_AlgebraicNumber:>a[[1]],\[Infinity]]])];
Print["Lifting to Q[\[Zeta]["<>ToString[N]<>"]]"];
{S,T}={S,T}/.a:AlgebraicNumber[z_,_]:>AlgebraicNumberPolynomial[a,\[Zeta][N]^(N/IdentifyRootOfUnity[z])];
{lastS,lastT}={S,T};
Print["Computing eigenspaces..."];
eigenspaces=Table[(*Print[i];*)NullSpace[T-\[Zeta][N]^(i N/q) IdentityMatrix[Length[T]],"Method"->"OneStepRowReduction"],{i,0,q-1}];
Q=Transpose[Join@@eigenspaces];
Print["Inverting change of basis..."];
lastQ=Q;
invQ=Inverse[Q,"Method"->"OneStepRowReduction"];
Print["Done!"];
{invQ.S.Q,invQ.T.Q}
]


(* ::Input::Initialization:: *)
SaveGenerators[]:=AbortProtect[Put[Cases[SubValues[ExplicitGenerators],r_/;FreeQ[r,Verbatim[Blank[]]]],FileNameJoin[{dataDirectory,"explicitGenerators.m"}]]]
LoadGenerators[]:=Module[{filename=FileNameJoin[{dataDirectory,"explicitGenerators.m"}]},
If[FileExistsQ[filename],
(SubValues[ExplicitGenerators]=Get[filename]~Join~SubValues[ExplicitGenerators];)
]
]


(* ::Input::Initialization:: *)
LoadGenerators[]


(* ::Input::Initialization:: *)
Clear[ReadCharacterTable]
ReadCharacterTable[gapName_List]:=ReadCharacterTable@@gapName
ReadCharacterTable[gapName_]:=ReadCharacterTable["",gapName]
ReadCharacterTable[stuff_,gapName_]:=ReadCharacterTable[stuff,gapName]=Module[{lines},
lines=ExecuteGAP[stuff<>"Display(CharacterTable("<>gapName<>"));"];
Print["Calculated the character table for "<>gapName<>":"];
Print[TableForm[lines]];
lines=Take[lines,{3,-1}+Flatten[Position[lines,s_/;StringMatchQ[s,"gap>"~~___],{1},Heads->False]]];
lines
]


(* ::Input::Initialization:: *)
VerifyUnitarity[table_]:=Module[{table1,M,conjugacyClassSizes},
table1=ToCyclotomicField[table];
M=AlgebraicConjugate[Transpose[table1]].table1;
conjugacyClassSizes=Table[M[[k,k]],{k,1,Length[M]}];
conjugacyClassSizes=conjugacyClassSizes[[1]]/conjugacyClassSizes;
table1.AlgebraicConjugate[conjugacyClassSizes Transpose[table1]]/(Plus@@conjugacyClassSizes)===IdentityMatrix[Length[M]]
]


(* ::Input::Initialization:: *)
VerifyUnitarityNumerically[table_]:=Module[{table1,M,conjugacyClassSizes},
table1=N[table,100];
M=Conjugate[Transpose[table1]].table1;
conjugacyClassSizes=Table[M[[k,k]],{k,1,Length[M]}];
conjugacyClassSizes=Round[conjugacyClassSizes[[1]]/conjugacyClassSizes];
Union[Flatten[Chop[table1.Conjugate[conjugacyClassSizes Transpose[table1]]/(Plus@@conjugacyClassSizes)-IdentityMatrix[Length[M]]]]]==={0}
]


(* ::Input::Initialization:: *)
(*Clear[CharacterTable]*)
CharacterTable[n_Integer]:=CharacterTable[GAP[SL[2,Subscript[Z, n]]]]
CharacterTable[gapName__]:=CharacterTable[gapName]=Module[{lines,Xpos,conjugacyClasses,representations,values,numberOfConjugacyClasses,parseRepresentation,result},
lines=ReadCharacterTable[gapName];
Xpos=Flatten[Position[lines,s_String/;StringMatchQ[s,"X."~~___]]];
conjugacyClasses=lines[[Min[Xpos]-2]];
representations=lines[[Xpos]];
values=If[Max[Xpos]+1>Length[lines],{},Cases[Drop[lines,Max[Xpos]+1],s_String/;!StringMatchQ[s,Whitespace~~"= "~~___]]];
numberOfConjugacyClasses=Length[StringSplit[conjugacyClasses,Whitespace]];

values=StringSplit[#," = "]/.{n_,v_}:>n->(ToExpression[StringReplace[v,"E("~~k:(DigitCharacter..)~~")":>"FusionAtlas`\[Zeta]["<>k<>"]"]])&/@values;

parseRepresentation[line_]:=StringReplace[Rest[StringSplit[line,Whitespace]],{"."->"0"}]/.{n_String/;StringMatchQ[n,NumberString]:>ToExpression[n],
n_String/;StringMatchQ[n,"-"~~LetterCharacter..]:>-(StringDrop[n,1]/.values),
n_String/;StringMatchQ[n,"\\*"~~LetterCharacter..]:>UniqueGaloisConjugate[(StringDrop[n,1]/.values)],
n_String/;StringMatchQ[n,"-\\*"~~LetterCharacter..]:>-UniqueGaloisConjugate[(StringDrop[n,2]/.values)],
n_String/;StringMatchQ[n,"/"~~LetterCharacter..]:>AlgebraicConjugate[(StringDrop[n,1]/.values)],
n_String/;StringMatchQ[n,"-/"~~LetterCharacter..]:>-AlgebraicConjugate[(StringDrop[n,2]/.values)],
n_String/;StringMatchQ[n,LetterCharacter..]:>(n/.values)};

result=parseRepresentation/@representations;
If[!VerifyUnitarityNumerically[result],Print["Something went wrong; the character table doesn't look right: "];Print[result];
Print[TableForm[lines]];
Abort[]];
result
]


(* ::Input::Initialization:: *)
SaveCharacterTables[]:=AbortProtect[Put[Cases[DownValues[CharacterTable],r_/;FreeQ[r,Blank|BlankSequence|BlankNullSequence]],FileNameJoin[{dataDirectory,"characterTables.m"}]]]
LoadCharacterTables[]:=
Module[{filename=FileNameJoin[{dataDirectory,"characterTables.m"}]},
If[FileExistsQ[filename],
(DownValues[CharacterTable]=Get[filename]~Join~DownValues[CharacterTable];)
]
]


(* ::Input::Initialization:: *)
LoadCharacterTables[];


(* ::Input::Initialization:: *)
Clear[ConjugacyClassOf]
ConjugacyClassOf[q_][m_]:=ConjugacyClassOf[q][m]=Module[{cmd,lines},
cmd="Position(ConjugacyClasses("<>GAP[SL[2,Subscript[Z, q]]]<>"),ConjugacyClass("<>GAP[SL[2,Subscript[Z, q]]]<>","<>StringReplace[ToString[m],{"{"->"[","}"->"]"}]<>"*One(Integers mod "<>ToString[q]<>")));";
lines=ExecuteGAP[cmd];
ToExpression[StringDrop[lines[[-2]],5]]
]


(* ::Input::Initialization:: *)
SaveConjugacyClasses[]:=Module[{},
AbortProtect[Put[Cases[SubValues[ConjugacyClassOf],r_/;FreeQ[r,Verbatim[Blank[]]]],FileNameJoin[{dataDirectory,"conjugacyClasses.m"}]]];
AbortProtect[Put[Cases[DownValues[ConjugacyClassesOfPowersOfT],r_/;FreeQ[r,Blank]],FileNameJoin[{dataDirectory,"conjugacyClassesOfPowersOfT.m"}]]];
AbortProtect[Put[Cases[DownValues[ConjugacyClassesOfGalois],r_/;FreeQ[r,Blank]],FileNameJoin[{dataDirectory,"conjugacyClassesOfGalois.m"}]]];
]
LoadConjugacyClasses[]:=Module[{},
If[FileExistsQ[FileNameJoin[{dataDirectory,"conjugacyClasses.m"}]],
SubValues[ConjugacyClassOf]=Get[FileNameJoin[{dataDirectory,"conjugacyClasses.m"}]]~Join~SubValues[ConjugacyClassOf];
];
If[FileExistsQ[FileNameJoin[{dataDirectory,"conjugacyClassesOfPowersOfT.m"}]],
DownValues[ConjugacyClassesOfPowersOfT]=Get[FileNameJoin[{dataDirectory,"conjugacyClassesOfPowersOfT.m"}]]~Join~DownValues[ConjugacyClassesOfPowersOfT];
];
If[FileExistsQ[FileNameJoin[{dataDirectory,"conjugacyClassesOfGalois.m"}]],
DownValues[ConjugacyClassesOfGalois]=Get[FileNameJoin[{dataDirectory,"conjugacyClassesOfGalois.m"}]]~Join~DownValues[ConjugacyClassesOfGalois];
];
]


(* ::Input::Initialization:: *)
ConjugacyClassesOfGalois[q_]/;PrimePowerQ[q]:=ConjugacyClassesOfGalois[q]=Module[{galois,cmd,lines},
galois=StringReplace[ToString[GaloisGroup[q]],{"{"->"[","}"->"]"}];
cmd = "m := "<>ToString[q] <>";; G := Group([[[0,-1],[1,0]],[[1,1],[0,1]]]*One(Integers mod m));; cc := ConjugacyClasses(G);; List("<>galois<>", n -> Position(cc,ConjugacyClass(G,[[n, 0], [0, n^(-1)]]*One(Integers mod m))));";
lines=ExecuteGAP[cmd];
Rule@@#&/@Transpose[{GaloisGroup[q],ToExpression[StringReplace[StringDrop[lines[[-2]],5],{"["->"{","]"->"}"}]]}]
]


(* ::Input::Initialization:: *)
ConjugacyClassesOfPowersOfT[q_]/;PrimePowerQ[q]:=ConjugacyClassesOfPowersOfT[q]=Module[{cmd,lines},
cmd = "m := "<>ToString[q] <>";; G := Group([[[0,-1],[1,0]],[[1,1],[0,1]]]*One(Integers mod m));; cc := ConjugacyClasses(G);; List([0..(m-1)], n -> Position(cc,ConjugacyClass(G,[[1, n], [0, 1]]*One(Integers mod m))));";
lines=ExecuteGAP[cmd];
ToExpression[StringReplace[StringDrop[lines[[-2]],5],{"["->"{","]"->"}"}]]
]


(* ::Input::Initialization:: *)
LoadConjugacyClasses[]


(* ::Input::Initialization:: *)
(*GaloisMatrix[n_,l_]:=GaloisMatrix[n,l]=With[{c={{-1,0},{0,-1}},s={{0,1},{-1,0}},t={{1,0},{1,1}}},Mod[c.s.{{1,PowerMod[l,-1,n]},{0,1}}.s.{{1,l},{0,1}}.s.{{1,PowerMod[l,-1,n]},{0,1}},n]]*)


(* ::Input::Initialization:: *)
Clear[GaloisInRepresentation]
GaloisInRepresentation[q_/;PrimePowerQ[q],k_Integer (* which irrep *),l_(* which Galois element *)]:=GaloisInRepresentation[q,k,l]=Module[{S,T},
{S,T}=ExplicitGenerators[q][k];
MatrixPower[S,3].MatrixPower[T,PowerMod[l,-1,q]].S.MatrixPower[T,PowerMod[l,1,q]].S.MatrixPower[T,PowerMod[l,-1,q]]
]


(* ::Input::Initialization:: *)
BlockDiagonalMatrix=With[{r=MapIndexed[#2[[1]] {1,1}->#&,#,1]},Normal[SparseArray`SparseBlockMatrix[r]]]&;


(* ::Input::Initialization:: *)
GaloisInRepresentation[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *),l_ (* which Galois element *)]:=
KroneckerProduct@@Table[GaloisInRepresentation[p[[1]],p[[2]],Mod[l,p[[1]]]]/.a_AlgebraicNumber:>AlgebraicNumberPolynomial[a,\[Zeta][n]^(n/IdentifyRootOfUnity[a[[1]]])],{p,Transpose[{PrimePowers[n],ks}]}]
GaloisInRepresentation[n_Integer,Vs:{{__Integer}..},l_]:=BlockDiagonalMatrix[Table[GaloisInRepresentation[n,V,l],{V,Vs}]]


(* ::Input::Initialization:: *)
TraceOfGalois[q_/;PrimePowerQ[q],k_Integer(* which irrep *),l_ (* which Galois element *)]:=CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[k,l/.ConjugacyClassesOfGalois[q]]]


(* ::Input::Initialization:: *)
TraceOfGalois[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *),l_ (* which Galois element *)]:=TraceOfGalois[n,ks,l]=
Product[TraceOfGalois[p[[1]],p[[2]],Mod[l,p[[1]]]],{p,Transpose[{PrimePowers[n],ks}]}]
TraceOfGalois[n_Integer,Vs:{{__Integer}..},l_]:=Sum[TraceOfGalois[n,V,l],{V,Vs}]


(* ::Input::Initialization:: *)
GaloisGroup[n_]:=GaloisGroup[n]=Cases[Table[i,{i,1,n-1}],i_/;GCD[i,n]==1]


(* ::Input::Initialization:: *)
GaloisConjugates[n_][AlgebraicNumber[s_,a_]]/;s==\[Zeta][n][[1]]:=Table[AlgebraicNumber[s,Flatten[Transpose[{a}~Join~Table[0,{m-1},{Length[a]}]]]],{m,GaloisGroup[n]}]
GaloisConjugates[n_][k:(_Integer|_Rational)]:=Table[k,{m,GaloisGroup[n]}]


(* ::Input::Initialization:: *)
GaloisInverse[n_][l_]:=PowerMod[l,-1,n]


(* ::Input::Initialization:: *)
GaloisAction[n_][l_][a:AlgebraicNumber[r_,x_]]/;r==\[Zeta][n][[1]]:=GaloisAction[n][l][a]=AlgebraicNumberPolynomial[a,\[Zeta][n]^l]
GaloisAction[n_][l_][a:(_Integer|_Rational)]:=a


(* ::Input::Initialization:: *)
Clear[GaloisGroupRepresentatives]
GaloisGroupRepresentatives[n_]:=GaloisGroupRepresentatives[n]=Module[{iterators,a},
iterators=Table[{a[i],0,MultiplicativeOrder[GaloisGroupGenerators[n][[i]],n]-1},{i,1,Length[GaloisGroupGenerators[n]]}];
#[[2]]->#[[1]]&/@Tally[Flatten[Table[{Table[a[i],{i,1,Length[GaloisGroupGenerators[n]]}],Mod[Product[GaloisGroupGenerators[n][[i]]^a[i],{i,1,Length[GaloisGroupGenerators[n]]}],n]},Evaluate[Sequence@@iterators]],Length[GaloisGroupGenerators[n]]-1],#1[[2]]==#2[[2]]&][[All,1]]
]


(* ::Input::Initialization:: *)
GaloisGroupElementAsProductOfGenerators[n_,k_]:=k/.GaloisGroupRepresentatives[n]


(* ::Input::Initialization:: *)
Clear[GeneratorsOfUnitsModPrimePower]


(* ::Input::Initialization:: *)
GeneratorsOfUnitsModPrimePower[q_]/;PrimePowerQ[q]\[And]FactorInteger[q][[1,1]]!=2:=GeneratorsOfUnitsModPrimePower[q]=Module[{p,n=1},
p=FactorInteger[q][[1,1]];
While[!CoprimeQ[n,q]\[Or]MultiplicativeOrder[n,q]!=q/p (p-1),n++];
{n}
]


(* ::Input::Initialization:: *)
GeneratorsOfUnitsModPrimePower[2]={};
GeneratorsOfUnitsModPrimePower[4]={3};


(* ::Input::Initialization:: *)
GeneratorsOfUnitsModPrimePower[q_]/;PrimePowerQ[q]\[And]FactorInteger[q][[1,1]]==2/;q>=8:=(*GeneratorsOfUnitsModPrimePower[q]=*){3}~Join~Take[Complement[{q/2-1,q/2+1,q-1},PowerMod[3,Range[q-1],q]],1]


(* ::Input::Initialization:: *)
GaloisGroupGenerators[n_]:=Module[{factors=#[[1]]^#[[2]]&/@FactorInteger[n],m},
m=Length[factors];
Flatten[Table[ChineseRemainder[(g-1)UnitVector[m,i]+1,factors],{i,1,m},{g,GeneratorsOfUnitsModPrimePower[factors[[i]]]}]]
]



(* ::Input::Initialization:: *)
SInRepresentation[q_/;PrimePowerQ[q],k_Integer (* which irrep *)]:=ExplicitGenerators[q][k][[1]]
TInRepresentation[q_/;PrimePowerQ[q],k_Integer (* which irrep *)]:=ExplicitGenerators[q][k][[2]]


(* ::Input::Initialization:: *)
(* Sometimes S will lie in an even larger number field. *)


(* ::Input::Initialization:: *)
Unprotect[KroneckerProduct];
KroneckerProduct[X_]:=X
Protect[KroneckerProduct];


(* ::Input::Initialization:: *)
SInRepresentation[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *)]:=
LiftToCommonCyclotomicField[KroneckerProduct@@Table[SInRepresentation[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],ks}]}]]
SInRepresentation[n_Integer,Vs:{{__Integer}..}]:=LiftToCommonCyclotomicField[BlockDiagonalMatrix[Table[SInRepresentation[n,V],{V,Vs}]]]
TInRepresentation[n_Integer,ks:{__Integer} (* a product of irreps for the prime powers *)]:=
KroneckerProduct@@Table[TInRepresentation[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],ks}]}]/.a_AlgebraicNumber:>AlgebraicNumberPolynomial[a,\[Zeta][n]^(n/IdentifyRootOfUnity[a[[1]]])]
TInRepresentation[n_Integer,Vs:{{__Integer}..}]:=BlockDiagonalMatrix[Table[TInRepresentation[n,V],{V,Vs}]]


(* ::Input::Initialization:: *)
Clear[FPDimensions,GlobalDimension,DimensionsFromFusionRules,DimensionsFromInductionMatrix,DimensionsFromFusionRulesAndInductionMatrix]


(* ::Input::Initialization:: *)
FPDimensions[fr_FusionRules]:=FPDimensions[fr]=Max[Cases[Eigenvalues[#],x_/;Im[x]==0]]&/@fr[[2,1,2]]
GlobalDimension[fr_FusionRules]:=GlobalDimension[fr]=ToCyclotomicField[Norm[FPDimensions[fr]]^2][[1]]


(* ::Input::Initialization:: *)
DimensionsFromFusionRules[fusion_]:=DimensionsFromFusionRules[fusion]=Module[{\[ScriptCapitalD],N},
\[ScriptCapitalD]=GlobalDimension[fusion];
N=Switch[\[ScriptCapitalD],_AlgebraicNumber,IdentifyRootOfUnity[\[ScriptCapitalD][[1]]],_,1];
{\[ScriptCapitalD],cachedToNumberField[#,\[Zeta][N]]&/@FPDimensions[fusion]}
]


(* ::Input::Initialization:: *)
DimensionsFromFusionRulesAndInductionMatrix[fusion_,induction_]:=DimensionsFromFusionRulesAndInductionMatrix[fusion, induction]=Module[{\[ScriptCapitalD],dims},
{\[ScriptCapitalD],dims}=DimensionsFromFusionRules[fusion];
{\[ScriptCapitalD],Transpose[induction].dims}
]


(* ::Input::Initialization:: *)
DimensionsFromInductionMatrix[inductionMatrix_]:=DimensionsFromInductionMatrix[inductionMatrix]=Module[{dimensions,n},
dimensions=RootReduce[Together[Eigenvectors[Transpose[inductionMatrix].inductionMatrix]]];
dimensions=Plus@@(RootReduce[#/Norm[#]]&/@Cases[dimensions,d_/;And@@(NonNegative[d])]);
dimensions=RootReduce[dimensions/Min[dimensions]];
dimensions=ToCyclotomicField[dimensions];
n=(Cases[dimensions,a_AlgebraicNumber:>IdentifyRootOfUnity[a[[1]]],1]~Join~{1})[[1]];
{n,{cachedToNumberField[Sum[d^2,{d,dimensions}]^(1/2),\[Zeta][n]],dimensions}}
]


(* ::Input::Initialization:: *)
DimensionsFromInductionMatrix[N_,inductionMatrix_]:=DimensionsFromInductionMatrix[N,inductionMatrix]=
Module[{n,dims},
{n,dims}=DimensionsFromInductionMatrix[inductionMatrix];
dims/.x_AlgebraicNumber:>AlgebraicNumberPolynomial[x,\[Zeta][N]^(N/n)]
]


(* ::Input::Initialization:: *)
SaveDimensionsFromInductionMatrix[]:=(LoadDimensionsFromInductionMatrixOnce[];AbortProtect[Put[Cases[DownValues[DimensionsFromInductionMatrix],r_/;FreeQ[r,Blank]],FileNameJoin[{dataDirectory,"dimensionsFromInductionMatrix.m"}]]])
LoadDimensionsFromInductionMatrixOnce[]:=LoadDimensionsFromInductionMatrixOnce[]=LoadDimensionsFromInductionMatrix[]
LoadDimensionsFromInductionMatrix[]:=Module[{filename=FileNameJoin[{dataDirectory,"dimensionsFromInductionMatrix.m"}]},
If[FileExistsQ[filename],
DownValues[DimensionsFromInductionMatrix]=Get[filename]~Join~DownValues[DimensionsFromInductionMatrix]
];
]


(* ::Input::Initialization:: *)
Clear[CheckGaloisVerlinde]


(* ::Input::Initialization:: *)
CheckGaloisVerlinde[inductionMatrix_]:=Module[{n,dimensions},
{n,dimensions}=DimensionsFromInductionMatrix[inductionMatrix];
CheckGaloisVerlinde[n,dimensions]
]


(* ::Input::Initialization:: *)
CheckGaloisVerlinde[fusion_FusionRules,inductionMatrix_?MatrixQ]:=Module[{N,dimensions},
dimensions=DimensionsFromFusionRulesAndInductionMatrix[fusion,inductionMatrix];
N=Switch[dimensions[[1]],_AlgebraicNumber,IdentifyRootOfUnity[dimensions[[1,1]]],_,1];
CheckGaloisVerlinde[N,dimensions]
]


(* ::Input::Initialization:: *)
CheckGaloisVerlinde[n_Integer,dimensions:{_?NumericQ,{___?NumericQ}}]:=CheckGaloisVerlinde[n,dimensions]=Module[{S,galoisElements},
S[1]=dimensions[[2]]/dimensions[[1]];
S[l_]:=S[l]=GaloisAction[n][l]/@S[1];
galoisElements=(Sort[#[[2,All,1]]]&/@Normal[GroupBy[Table[{l,S[l]},{l,GaloisGroup[n]}],#[[2]]&]])[[All,1]];
And@@(NonNegative[#]\[And]IntegerQ[#]&/@Flatten[Table[Sum[(S[x][[w]]S[y][[w]]AlgebraicConjugate[S[z][[w]]])/S[1][[w]],{w,1,Length[dimensions[[2]]]}],{x,galoisElements},{y,galoisElements},{z,galoisElements}]])
]


(* ::Input::Initialization:: *)
GaloisOrbitClumps[n_,dimension_]:=GaloisOrbitClumps[n,dimension]=Module[{clumps},
clumps=Union[#~Join~(-#)]&/@Outer[GaloisAction[n][#2][#1/dimension[[1]]]dimension[[1]]&,dimension[[2]],GaloisGroup[n]];
Sort[Flatten[Position[clumps,#]]&/@Union[clumps]]
]


(* ::Input::Initialization:: *)
GaloisOrbitClumps[induction_]:=GaloisOrbitClumps@@DimensionsFromInductionMatrix[induction]


(* ::Input::Initialization:: *)
(* TODO this could be tightened in many ways *)


(* ::Input::Initialization:: *)
Clear[PossibleConductors]


(* ::Input::Initialization:: *)
PossibleConductors[inductionMatrix_]:=PossibleConductors[inductionMatrix]=Module[{dimensionConductor,rank,inductionsFromOne,dimensions,\[ScriptCapitalD],n,primes,powers,l=3,largestClump},
dimensionConductor=DimensionsFromInductionMatrix[inductionMatrix][[1]];
dimensions=DimensionsFromInductionMatrix[inductionMatrix][[2,2]];
(*Print[dimensions];*)
rank=Length[dimensions];
inductionsFromOne=Count[inductionMatrix[[1]],Except[0]];
largestClump=Max@@(Length/@GaloisOrbitClumps[inductionMatrix]);
\[ScriptCapitalD]=Sum[d^2,{d,dimensions}];
n=Switch[\[ScriptCapitalD],_AlgebraicNumber,IdentifyRootOfUnity[\[ScriptCapitalD][[1]]],_,1];
primes=FactorInteger[AlgebraicNumberNorm[\[ScriptCapitalD]]][[All,1]];
sizeOfOrbit[p_,k_]:=p^(k-1) (p-1)/2;
sizeOfOrbit[2,k_]:=Max[1,2^(k-3)];
powers=Table[\[Infinity],{Length[primes]}];
While[(Max@@powers)>=l,
l++;
powers=Cases[Tuples[Table[Range[l],{Length[primes]}]],t_/;(Max@@Table[sizeOfOrbit[primes[[i]],t[[i]]],{i,1,Length[primes]}]<=largestClump)\[And](Sum[sizeOfOrbit[primes[[i]],t[[i]]],{i,1,Length[primes]}]<=rank-inductionsFromOne)];
];
Cases[Times@@(primes^#)&/@powers,N_/;Mod[N,dimensionConductor]==0]
]


(* ::Input::Initialization:: *)
Clear[PossibleGaloisImages,PossibleGaloisImagesWithSigns];


(* ::Input::Initialization:: *)
PossibleGaloisImages[n_,dimensions_,1]:=Table[{i},{i,1,Length[dimensions[[2]]]}];
PossibleGaloisImages[n_,dimensions_,l_]:=PossibleGaloisImages[n,dimensions,l]=Module[{images},
images=GaloisAction[n][l][#/dimensions[[1]]]dimensions[[1]]&/@dimensions[[2]];
Flatten[Position[dimensions[[2]],#|(-#),1]]&/@images
]
PossibleGaloisImages[n_,dimensions_]:=Table[l->PossibleGaloisImages[n,dimensions,l],{l,GaloisGroup[n]}]


(* ::Input::Initialization:: *)
PossibleGaloisImages[n_,induction_?MatrixQ]:=PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,induction]]


(* ::Input::Initialization:: *)
PossibleGaloisImagesWithSigns[n_,dimensions_,1]:=Table[{i},{i,1,Length[dimensions[[2]]]}];
PossibleGaloisImagesWithSigns[n_,dimensions_,l_]:=PossibleGaloisImagesWithSigns[n,dimensions,l]=Module[{images},
images=GaloisAction[n][l][#/dimensions[[1]]]dimensions[[1]]&/@dimensions[[2]];
Flatten[Position[dimensions[[2]],#,1]~Join~(-Position[dimensions[[2]],-#,1])]&/@images
]


(* ::Input::Initialization:: *)
PossibleGaloisImages[n_Integer,dimensions_List,eigenvalues_List,1]:=Table[{i},{i,1,Length[dimensions[[2]]]}]
PossibleGaloisImages[n_Integer,dimensions_List,eigenvalues_List,l_Integer]:=PossibleGaloisImages[n,dimensions,eigenvalues,l]=Module[{images},
images={GaloisAction[n][l][#[[1]]/dimensions[[1]]]dimensions[[1]],Mod[l^2 #[[2]],1]}&/@Transpose[{dimensions[[2]],eigenvalues}];
Flatten[Position[Transpose[{dimensions[[2]],eigenvalues}],{#[[1]]|(-#[[1]]),#[[2]]},1]]&/@images
]


(* ::Input::Initialization:: *)
Clear[PossibleGaloisTraces]


(* ::Input::Initialization:: *)
possibleSums[{x_List}]:=x
possibleSums[{x_List,y_List,z___List}]:=possibleSums[{Union[Flatten[Outer[Plus,x,y,1]]],z}]


(* ::Input::Initialization:: *)
PossibleGaloisTraces[n_,dimensions_,l_]:=PossibleGaloisTraces[n,dimensions,l]=Module[{images,contributions},
images=Transpose[{Range[Length[dimensions[[2]]]],PossibleGaloisImagesWithSigns[n,dimensions,l]}];
contributions[{k_,i_}]/;MemberQ[i,k]\[And]Length[i]>1:={1,0};
contributions[{k_,i_}]/;MemberQ[i,-k]\[And]Length[i]>1:={-1,0};
contributions[{k_,i_}]/;MemberQ[i,k]\[And]Length[i]==1:={1};
contributions[{k_,i_}]/;MemberQ[i,-k]\[And]Length[i]==1:={-1};
contributions[{k_,i_}]/;!MemberQ[i,k]\[And]!MemberQ[i,-k]:={0};
possibleSums[contributions/@images]
]
PossibleGaloisTraces[n_,dimensions_]:=Table[l->PossibleGaloisTraces[n,dimensions,l],{l,GaloisGroup[n]}]


(* ::Input::Initialization:: *)
MaximumGaloisFixedPoints[n_,dimensions_,l_]:=MaximumGaloisFixedPoints[n,dimensions,l]=With[{\[ScriptCapitalD]=dimensions[[1]]},Count[dimensions[[2]],d_/;With[{ga=GaloisAction[n][l][d/\[ScriptCapitalD]]\[ScriptCapitalD]},ga==d||ga==-d]]]
MaximumGaloisFixedPoints[n_,dimensions_]:=Table[l->MaximumGaloisFixedPoints[n,dimensions,l],{l,GaloisGroup[n]}]


(* ::Input::Initialization:: *)
RepresentationSign[q_,k_Integer]/;PrimePowerQ[q]:=RepresentationSign[q,k]=Sign[CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[k,ConjugacyClassOf[q][{{-1,0},{0,-1}}]]]]
RepresentationSign[n_,ts:{__Integer}]:=Product[RepresentationSign[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],ts}]}]


(* ::Input::Initialization:: *)
totalModOne[x___]:=Mod[Total[{x}],1]


(* ::Input::Initialization:: *)
TEigenvalues[N_,t:{__Integer}]:=TEigenvalues[N,t]=Module[{primePowers=#[[1]]^#[[2]]&/@FactorInteger[N]},
Flatten[Outer[totalModOne,Sequence@@Table[TEigenvalues[primePowers[[i]],t[[i]]],{i,1,Length[primePowers]}]]]
]
TEigenvalues[N_,ts:{{__Integer}...}]:=TEigenvalues[N,#]&/@ts


(* ::Input::Initialization:: *)
(* Given \[Chi] = ( tr(M^r) )_{r=0}^{n-1}, this lists all the eigenvalues of M which are n-th roots of unity. *)
NewtonsIdentity[n_,\[Chi]_]:=Join@@Table[Table[m/n,{RootReduce[1/n \[Chi].Table[\[Zeta][n]^(-m l),{l,0,n-1}]]}],{m,0,n-1}]


(* ::Input::Initialization:: *)
TEigenvalues[q_,k_Integer]/;PrimePowerQ[q]:=TEigenvalues[q,k]=Module[{\[Chi]},
lastTEigenvalues={q,k};
\[Chi]=liftCyclotomicNumber[q]/@Table[CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[k,l]],{l,ConjugacyClassesOfPowersOfT[q]}];
NewtonsIdentity[q,\[Chi]]
]


(* ::Input::Initialization:: *)
liftCyclotomicNumber[N_][x:(_Integer|_Rational)]:=x
liftCyclotomicNumber[N_][a_AlgebraicNumber]:=liftCyclotomicNumber[N][a]=With[{n=LCM[N,IdentifyRootOfUnity[a[[1]]]]},
AlgebraicNumberPolynomial[a,\[Zeta][n]^(n/IdentifyRootOfUnity[a[[1]]])]
]


(* ::Input::Initialization:: *)
SaveTEigenvalues[]:=AbortProtect[Put[Cases[DownValues[TEigenvalues],r_/;FreeQ[r,Verbatim[Blank[]]]],FileNameJoin[{dataDirectory,"tEigenvalues.m"}]]]
LoadTEigenvalues[]:=(DownValues[TEigenvalues]=Get[FileNameJoin[{dataDirectory,"tEigenvalues.m"}]]~Join~DownValues[TEigenvalues];)


(* ::Input::Initialization:: *)
RepresentationConductor[N_,{}]:=1
RepresentationConductor[N_,t:{__Integer}]:=RepresentationConductor[N,t]=LCM@@(Denominator/@TEigenvalues[N,t])
RepresentationConductor[N_,ts:{{__Integer}...}]:=LCM@@(RepresentationConductor[N,#]&/@ts)


(* ::Input::Initialization:: *)
RepresentationDimension[q_,t_Integer]/;PrimePowerQ[q]:=RepresentationDimension[q,t]=CharacterTable[GAP[SL[2,Subscript[Z, q]]]][[t,1]]
RepresentationDimension[n_,t:{__Integer}]:=Product[RepresentationDimension[p[[1]],p[[2]]],{p,Transpose[{PrimePowers[n],t}]}]
RepresentationDimension[n_,ts:{{__Integer}...}]:=Sum[RepresentationDimension[n,t],{t,ts}]


(* ::Input::Initialization:: *)
addMaps[m1_,m2_]:=Module[{keys},
keys=Union[m1[[All,1]]~Join~m2[[All,1]]];
#->Replace[#,m1~Join~{_->0}]+Replace[#,m2~Join~{_->0}]&/@keys
]


(* ::Input::Initialization:: *)
$RecursionLimit=4000;


(* ::Input::Initialization:: *)
RepresentationsForRankDirty={};


(* ::Input::Initialization:: *)
RepresentationsForRank[n_,r_]:=RepresentationsForRank[n,r]=Module[{characterTables,tuples,PartialRepresentation,addRepresentation,addRepresentations,representations,factors,trivial},
Print["Enumerating allowed representation types for conductor ",n, " and rank " ,r,"."];
characterTables=CharacterTable[GAP[SL[2,Subscript[Z, #]]]]&/@PrimePowers[n];
(*characterTables0=characterTables;*)
(* We assemble a list of all the irreps, whose dimensions is at most r *)
(* If PrimePowers[n]={5,13}, an element {3,7} in tuples indicates the tensor product of the 3rd irrep of SL(2,Z/5Z) and the 7th irrep of
SL(2,Z/13Z). *)
tuples=Cases[Flatten[Outer[List,Sequence@@ Range[Length/@characterTables]],Length[PrimePowers[n]]-1],t_/;RepresentationDimension[n,t]<=r];
(*tuples0=tuples;*)
(* We next clump the irreps according to their conductor, and sort the list of clumps so that conductors divisible by Subscript[p, i]^Subscript[n, i] for the largest Subscript[p, i] come first, after that conductors divisible by the prime power corresponding to the second largest prime come next, and so one, and then we put the largest conductors first. *)
tuples=SortBy[Normal[GroupBy[tuples,RepresentationConductor[n,#]&]],Function[p,{!Divisible[p[[1]],#]&/@Reverse[PrimePowers[n]],-p[[1]]}]];
(*tuples0=tuples;*)
(* We next sort each clump, so that irreps with a T eigenvalue of 0 come first, and after that so even representations come before odd representatiosn. *)
tuples=#[[1]]->SortBy[#[[2]],Function[ts,{!MemberQ[TEigenvalues[n,ts],0],-RepresentationSign[n,ts]}]]&/@tuples;
(*tuples0=tuples;*)
addRepresentation[{},conductor_Integer][pr_PartialRepresentation]:={pr};
(* This function takes care of adding all representations with a given conductor. *)
(* Implementation note: the arguments open and signedMultiplicities are not actually used. Respectively, they keep track of
eigenvalues which have appeared alonside 0, and the signed multiplicities of each eigenvalue so far. *)
addRepresentation[{t:{__Integer},others___},conductor_Integer][pr:PartialRepresentation[ts:{{__Integer}...},remainingDimension_Integer,open_List,signedMultiplicities_List]]:=Module[{max,min},
(*pr0=Take[pr,2];*)
max=Floor[remainingDimension/RepresentationDimension[n,t]];
(* TODO?: check that either this representation has 0, or any eigenvalues which could not appear *later*, have already appeared alongside 0 (and so are recorded in "open"). *)
(* TODO?: We could try checking multiplicities of eigenvalues in even and odd representations: if we're sure some eigenvalue
can _only_ appear in odd representations from now on, that gives us a potentially tighter upper bound on how many times we can use an odd representations containing that eigenvalue. *)
(* This next commented block of code was an earlier attempt to do this, which seems to have been incorrect. *)
(*If[!MemberQ[TEigenvalues[n,t],0]\[And]Negative[RepresentationSign[n,t]],
(* look at the signed multiplicities *)
min=Min@@(Replace[#\[LeftDoubleBracket]1\[RightDoubleBracket],signedMultiplicities~Join~{_\[Rule]0}]/#\[LeftDoubleBracket]2\[RightDoubleBracket]&/@Tally[TEigenvalues[n,t]]);
max=Min[max,min];
];*)
Join@@(addRepresentation[{others},conductor]/@Table[
If[k==0,
pr,
PartialRepresentation[
ts~Join~Table[t,{k}],
remainingDimension-k RepresentationDimension[n,t],
If[
MemberQ[TEigenvalues[n,t],0],
Union[open,TEigenvalues[n,t]],
open
],
addMaps[signedMultiplicities,Rule@@({1,k RepresentationSign[n,t]}#)&/@Tally[TEigenvalues[n,t]]]
]
],{k,0,max}])
];
addRepresentations[{}][pr_PartialRepresentation]:={pr};
(* This function takes care of adding all representations, by calling the previous function for each conductor. *)
addRepresentations[{conductor_Integer->(ts:{{__Integer}...}),others___}][pr_PartialRepresentation]:=Module[{result},
result=addRepresentation[ts,conductor][pr];
(*Print[Length[result]];*)
(*If the conductor is a prime power, that's the last time we will see that prime power, so make sure that by now we've actually used something with large enough conductor *)
If[MemberQ[PrimePowers[n],conductor],
If[MemberQ[{others}[[All,1]],N_/;Divisible[N,conductor]],
Print["Something seems to have gone wrong with the ordering of the irreps!"];Abort[]];
(*Print[RepresentationConductor[n,#]&/@result\[LeftDoubleBracket]All,1\[RightDoubleBracket]];*)
result=Cases[result,PartialRepresentation[Ts:{{__Integer}...},___]/;Divisible[RepresentationConductor[n,Ts],conductor]];
];
(*Print[Length[result]];*)
Join@@(addRepresentations[{others}]/@result)
];
If[tuples[[-1,1]]!=1, Print["Oops, I was expecting the last conductor to be 1!"];Abort[]];
If[Length[tuples[[-1,2]]]!=1,Print["Oops, I was expecting the only irrep with conductor 1 to be the trivial irrep!"];Abort[]];
representations=addRepresentations[Most[tuples]][PartialRepresentation[{},r-1,{},{}]][[All,1]];
trivial=tuples[[-1,2,1]];
representations=Map[{#,RepresentationDimension[n,#]}&,representations,{2}];
(* Fill up the remaining space with trivial representations *)
representations=#~Join~Table[{trivial,1},{r-Total[#[[All,2]]]}]&/@representations;
representations={#,TEigenvalues[n,#[[All,1]]]}&/@representations;
(* Check that every eigenvalue that appears appears with 0 in some irrep. *)
representations=Cases[representations,{V_,Ts_}/;And@@Table[MemberQ[Ts,T_/;MemberQ[T,0]\[And]MemberQ[T,t]],{t,Union[Flatten[Ts]]}]];
(* Check that the signed multiplicity of each irrep that appears is non-negative. *)
representations=Cases[representations,{V_,Ts_}/;And@@Table[(RepresentationSign[n,#]&/@(V[[All,1]])).(Count[#,t]&/@Ts)>=0,{t,Union[Flatten[Ts]]}]];
RepresentationsForRankDirty=Union[RepresentationsForRankDirty,{n}];
Print["Found ",Length[representations]," allowed representation types for conductor ",n, " and rank " ,r,"."];
representations
]


(* ::Input::Initialization:: *)
RepresentationsForDimensions[N_,dimensions:{\[ScriptCapitalD]_?NumericQ,{__?NumericQ}}]:=RepresentationsForDimensions[N,dimensions]=Module[{},
If[!MemberQ[RepresentationsForRankLoaded,N],LoadRepresentationsForRank[N]];
Cases[RepresentationsForRank[N,Length[dimensions[[2]]]],{V_,_}/;
And@@Table[MemberQ[PossibleGaloisTraces[N,dimensions,l],TraceOfGalois[N,V[[All,1]],l]],{l,GaloisGroup[N]}]]
]


(* ::Input::Initialization:: *)
RepresentationsForInductionMatrix[N_,inductionMatrix:{{__Integer}..}]:=Module[{dimensions,numberOfObjectsInInductionOfOne,result},
dimensions=DimensionsFromInductionMatrix[N,inductionMatrix];
numberOfObjectsInInductionOfOne=Count[inductionMatrix[[1]],Except[0]];
result=Cases[RepresentationsForDimensions[N,dimensions],{V_,Ts_}/;Count[Flatten[Ts],0]>=numberOfObjectsInInductionOfOne];
Print["Found ",Length[result]," allowed representation types for conductor ",N, " and induction matrix " ,MatrixForm[inductionMatrix],"."];
result
]


(* ::Input::Initialization:: *)
RepresentationsForRankProgress[]:=SortBy[(#[[1]]->Max@@(#[[2,All,2]]))&/@Normal[GroupBy[Cases[DownValues[RepresentationsForRank],(p_:>_)/;IntegerQ[p[[1,2]]]:>{p[[1,1]],p[[1,2]]}],#[[1]]&]],#[[2]]&]


(* ::Input::Initialization:: *)
SaveRepresentationsForRank[]:=SaveRepresentationsForRank/@RepresentationsForRankDirty;
LoadRepresentationsForRank[]:=Module[{data},
LoadRepresentationsForRank/@Flatten[StringCases[#,___~~"-"~~(n:(DigitCharacter..))~~".m.gz":>ToExpression[n]]&/@FileNames[FileNameJoin[{dataDirectory,"representationsForRank-*.m.gz"}]]];
]


(* ::Input::Initialization:: *)
SaveRepresentationsForRank[n_Integer]:=Module[{data,outputDirectory,timing},
If[!MemberQ[RepresentationsForRankLoaded,n],LoadRepresentationsForRank[n]];
data=Cases[DownValues[RepresentationsForRank],((p_:>v_)/;p[[1,1]]===n\[And]IntegerQ[p[[1,2]]]):>({p[[1,1]],p[[1,2]]}->v[[All,1,All,1]])];
If[Length[data]==0,
Print["Nothing to do."],
Print["Exporting data for conductor ",n,". Raw bytes: ",ByteCount[data]];
outputDirectory=FileNameJoin[{dataDirectory,"representationsForRank"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
timing=AbsoluteTiming[
GZIP[data,FileNameJoin[{outputDirectory,"representationsForRank-"<>ToString[n]<>".m.gz"}]]
][[1]];
Print["... completed in ",timing, " seconds."];
RepresentationsForRankDirty=DeleteCases[RepresentationsForRankDirty,n];
]
];
LoadRepresentationsForRank[n_Integer]:=Module[{file,data},
file=FileNameJoin[{dataDirectory,"representationsForRank","representationsForRank-"<>ToString[n]<>".m.gz"}];
If[FileExistsQ[file],
data=ImportGZIP[file];
Cases[data,({n,k_}->Vs_):>(RepresentationsForRank[n,k]=(Function[ts,{{#,RepresentationDimension[n,#]}&/@ts,TEigenvalues[n,#]&/@ts}]/@Vs))];
];
RepresentationsForRankLoaded=Union[RepresentationsForRankLoaded,{n}];
]


(* ::Input::Initialization:: *)
RepresentationsForRankLoaded={};


(* ::Input::Initialization:: *)
SaveAllModularData[]:=(SaveRepresentationsForRank[];SaveTEigenvalues[];SaveConjugacyClasses[];SaveCharacterTables[];
SaveGenerators[];)


(* ::Input::Initialization:: *)
workOnRepresentations[conductors_,rank_:\[Infinity]]:=Module[{status,min,i,timing,length,counter=0,cells={}},
LoadRepresentationsForRank/@conductors;
status={#,0.0,0,0}&/@conductors;
While[(Min@@status[[All,3]])<rank,
min=Min@@(status[[All,2]]+10.^-4 status[[All,4]]);
i=Position[status,{_,m_,_,l_}/;m+10.^-4 l<=min+10.^-6][[1,1]];
AppendTo[cells,PrintTemporary["Running RepresentationsForRank[",status[[i,1]],",",status[[i,3]]+1, "] ..."]];
{timing,length}=AbsoluteTiming[Length[RepresentationsForRank[status[[i,1]],status[[i,3]]+1]]];
AppendTo[cells,PrintTemporary["Took ",timing," seconds."]];
AppendTo[cells,PrintTemporary["Found ",length," decompositions."]];
If[Length[cells]>9,NotebookDelete/@Drop[cells,-9];cells=Take[cells,-9]];
status[[i]]={status[[i,1]],timing,status[[i,3]]+1,length};
status=DeleteCases[status,{_,_,rank,_}];
];
Print["Finished ... saving results."];
SaveRepresentationsForRank/@conductors;
]


(* ::Input::Initialization:: *)
LiftsOf1[inductionMatrix_]:=Flatten[Position[Transpose[inductionMatrix],{Except[0],___},1]]


(* ::Input::Initialization:: *)
ListDifference[{a___,b_,c___},{b_,d___}]:=ListDifference[{a,c},{d}]
ListDifference[L_,{}]:=L


(* ::Input::Initialization:: *)
AllocateEigenvaluesToGaloisOrbitClumps[n_Integer,inductionMatrix_]:=Module[{outputDirectory,filename,liftsOf1,result,EigenvalueClumps,allocations,AllocateEigenvaluesToGaloisOrbitClumpsImpl,AllocateEigenvaluesToGaloisOrbitClumpsImpl0},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToGaloisOrbitClumps"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>SHA1[inductionMatrix]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
Print["Allocating T-eigenvalues to Galois orbit clumps for ",MatrixForm[inductionMatrix]];
AllocateEigenvaluesToGaloisOrbitClumpsImpl0[X___]:=AllocateEigenvaluesToGaloisOrbitClumpsImpl0[X]=AllocateEigenvaluesToGaloisOrbitClumpsImpl[X];
AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations_,{}]:={allocations};
AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations_,{{eigenvalues_,0,minimumAllowedClump_:1},otherEigenvalues___}]:=AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations,{otherEigenvalues}];
AllocateEigenvaluesToGaloisOrbitClumpsImpl[allocations_,{{eigenvalues_,multiplicity_,minimumAllowedClump_:1},otherEigenvalues___}]:=Module[{positions},
(* decide which clumps have enough room *)
positions=Cases[Flatten[Position[allocations,{simples_,allocatedEigenvalues_}/;(Length[simples]-Length[allocatedEigenvalues]-Max[(Count[simples,Alternatives@@liftsOf1]-Count[allocatedEigenvalues,0]-Count[eigenvalues,0]),0]>=Length[eigenvalues]),1]],p_/;p>=minimumAllowedClump];
Join@@(Function[{p},AllocateEigenvaluesToGaloisOrbitClumpsImpl[ReplacePart[allocations,p->ReplacePart[allocations[[p]],2->allocations[[p,2]]~Join~eigenvalues]],{{eigenvalues,multiplicity-1,p},otherEigenvalues}]]/@positions)
];
EigenvalueClumps[{}]:={};
EigenvalueClumps[eigenvalues:{__?NumericQ}]:=EigenvalueClumps[eigenvalues]=Module[{clump},
clump=Union[Table[Mod[l^2 eigenvalues[[1]],1],{l,GaloisGroup[n]}]];
(* TODO does it matter whether we clump then join, or join then clump? *)
{clump}~Join~EigenvalueClumps[ListDifference[eigenvalues,clump]]
];
EigenvalueClumps[eigenvalueLists:{{__?NumericQ}..}]:=Join@@(EigenvalueClumps[#]&/@eigenvalueLists);

liftsOf1=LiftsOf1[inductionMatrix];
allocations=RepresentationsForInductionMatrix[n,inductionMatrix];
result=Join@@Map[Function[representation,representation~Join~{#}&/@AllocateEigenvaluesToGaloisOrbitClumpsImpl0[{#,{}}&/@GaloisOrbitClumps[n,DimensionsFromInductionMatrix[n,inductionMatrix]],Tally[EigenvalueClumps[representation[[2]]]]]],allocations];
GZIP[result,filename];
Print["Found ",Length[result], " ways to allocate T-eigenvalues to the Galois orbit clumps for ",MatrixForm[inductionMatrix]];
result
]
]


(* ::Input::Initialization:: *)
EquivalenceClassesOfSimples[inductionMatrix_]:=EquivalenceClassesOfSimples[inductionMatrix]=Normal[GroupBy[Range[Length[inductionMatrix[[1]]]],inductionMatrix[[All,#]]&]][[All,2]]


(* ::Input::Initialization:: *)
EquivalenceClassesOfSimples[induction_,eigenvalues_]:=Normal[GroupBy[Range[Length[induction[[1]]]],{induction[[All,#1]],eigenvalues[[#1]]}&]][[All,2]]


(* ::Input::Initialization:: *)
(*Clear[AllocateEigenvaluesToSimples]*)


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimples[n_,inductionMatrix_,clumps_]:=(*AllocateEigenvaluesToSimples[n,inductionMatrix,clumps]=*)
Module[{toAssign,result},
toAssign=SortBy[EquivalenceClassesOfSimples[inductionMatrix],Function[class,{-Length[Intersection[class,LiftsOf1[inductionMatrix]]],-DimensionsFromInductionMatrix[n,inductionMatrix][[2,class[[1]]]]}]];
result=AllocateEigenvaluesToSimples[n,inductionMatrix,clumps,toAssign,{},Chop[N[-DimensionsFromInductionMatrix[n,inductionMatrix][[1]]],10^-5],Chop[N[DimensionsFromInductionMatrix[n,inductionMatrix][[1]]^2],10^-5]];
Cases[result,r_/;And@@Table[Min@@(Length/@PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,inductionMatrix],r,l])>=1,{l,GaloisGroupGenerators[n]}]]
]


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimples[n_,inductionMatrix_,clumps_,{},assigned_,_,_]:=
Module[{t,T,\[ScriptCapitalD],d},
(* now we check the top left entry of STSTST=C exactly *)
t=Sort[assigned][[All,2]];
T=\[Zeta][n]^(n t);
(*counter++;*)
{\[ScriptCapitalD],d}=DimensionsFromInductionMatrix[n,inductionMatrix];
If[(d^2).T-\[ScriptCapitalD]==0,
{t},{}
]
]


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimples[n_,inductionMatrix_,clumps_,{toAssign_,others___},assigned_,partialSum_,totalRemainingDimension_]:=Module[{i,subsets,dims},
(*Print[{clumps,{toAssign,others},assigned,partialSum,totalRemainingDimension}];*)
If[Abs[N[partialSum]]>=totalRemainingDimension+1,
(*stoppedEarly++;*)
{},
dims=DimensionsFromInductionMatrix[n,inductionMatrix][[2,toAssign]];
i=Position[clumps,{simples_,_}/;Length[Intersection[simples,toAssign]]==Length[toAssign],1][[1,1]];
subsets=
If[Length[Intersection[LiftsOf1[inductionMatrix],toAssign]]>0,
{Table[0,{Length[toAssign]}]},
Union[Subsets[clumps[[i,2]],{Length[toAssign]}]]
];
(* we could try to filter the subsets early, checking compatibility with possible Galois actions. *)
(* for now, we just check after all have been allocated *)
Join@@(Function[subset,AllocateEigenvaluesToSimples[n,inductionMatrix,ReplacePart[clumps,i->{ListDifference[clumps[[i,1]],toAssign],ListDifference[clumps[[i,2]],subset]}],{others},assigned~Join~Thread[toAssign->subset],partialSum+(dims^2).(\[Zeta][n]^(n subset)),Chop[totalRemainingDimension-dims.dims]]]/@subsets)
]
]


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimples[n_,inductionMatrix_]:=Module[{outputDirectory,filename,result},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToSimples"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>SHA1[inductionMatrix]<>".m.gz"}];
If[(*False\[And]*)FileExistsQ[filename],
ImportGZIP[filename],
result=Join@@(Map[Function[A,{A[[1]],#}&/@AllocateEigenvaluesToSimples[n,inductionMatrix,A[[3]]]],AllocateEigenvaluesToGaloisOrbitClumps[n,inductionMatrix]]);
GZIP[result,filename];
Print["Found ",Length[result], " candidate T-matrices for ",MatrixForm[inductionMatrix]];
result]
]


(* ::Input::Initialization:: *)
FrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_]:=Module[{dims,\[ScriptCapitalD]},
{\[ScriptCapitalD],dims}=DimensionsFromInductionMatrix[n,inductionMatrix];
Table[
1/\[ScriptCapitalD] \!\(
\*UnderoverscriptBox[\(\[Sum]\), \(j = 1\), \(Length[inductionMatrix[[1]]]\)]\(
\*SuperscriptBox[\(\[Zeta][n]\), \(\((n\ Ts[[j]])\) k\)] dims[[j]] inductionMatrix[[m, j]]\)\),
{m,1,Length[inductionMatrix]}]
]


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators1[n_,fusion_,inductionMatrix_]:=Cases[
AllocateEigenvaluesToSimples[n,inductionMatrix], 
a_/;FrobeniusSchurIndicators[n,fusion,inductionMatrix][a[[2]]][1]==UnitVector[Length[inductionMatrix],1]
]


(* ::Input::Initialization:: *)
FusionPower[fusion_][i_ (* i-th object *),k_ (* raised to the k-th power *)]:=MatrixPower[fusion[[2,1,2,i]],k].UnitVector[Length[fusion[[2,1,2]]],1]


(* ::Input::Initialization:: *)
FrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_,l_]/;GCD[k,l]==1:=
Quiet[
Module[{fsind=FrobeniusSchurIndicators[n,fusion,inductionMatrix][Ts][k]},
Check[
GaloisAction[k][l][ToNumberField[#,\[Zeta][k]]],
$Failed,{ToNumberField::nnfel}]&/@fsind
],ToNumberField::nnfel]
FrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_,l_]:=Module[{g=GCD[k,l],result},
Table[
result=FusionPower[fusion][m,g].FrobeniusSchurIndicators[n,fusion,inductionMatrix][Ts][k/g,l/g];
If[FreeQ[result,$Failed],result,$Failed]
,{m,1,Length[inductionMatrix]}]
]


(* ::Input::Initialization:: *)
VerifyFrobeniusSchurIndicators[n_,fusion_,inductionMatrix_][Ts_][k_]:=Table[
{Module[{traces=Table[FrobeniusSchurIndicators[Ts][k,l][[m]],{l,0,k-1}]},
If[FreeQ[traces,$Failed],
Length[NewtonsIdentity[k,traces]],
-\[Infinity]]
],FusionPower[fusion][m,k][[1]]}
,
{m,1,Length[inductionMatrix]}]


(* ::Input::Initialization:: *)
reportedOnce=False;
reportFPIndicatorsInBadField[stuff___]:=(If[!reportedOnce,Print["Found a Frobenius-Schur indicator that isn't even in the correct field: ",{stuff}]];reportedOnce=True;)


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators[n_,fusion_,k0_,inductionMatrix_]:=Module[{outputDirectory,filename,result,allocated},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>ToString[k0]<>","<>SHA1[{fusion,inductionMatrix}]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
Print["Looking for T-matrices for ",DisplayGraph[fusion], " ",MatrixForm[inductionMatrix]];
allocated=AllocateEigenvaluesToSimples[n,inductionMatrix];
Print["... checking Frobenius-Schur indicators"];
result=Module[{pairs,cachedFrobeniusSchurIndicators,verifyFrobeniusSchurIndicators},
cachedFrobeniusSchurIndicators[Ts_][X___]:=cachedFrobeniusSchurIndicators[Ts][X]=FrobeniusSchurIndicators[n,fusion,inductionMatrix][Ts][X];
verifyFrobeniusSchurIndicators[Ts_][k_]:=verifyFrobeniusSchurIndicators[Ts][k]=Table[
{Module[{traces=Table[cachedFrobeniusSchurIndicators[Ts][k,l][[m]],{l,0,k-1}]},
If[FreeQ[traces,$Failed],
Length[NewtonsIdentity[k,traces]],
reportFPIndicatorsInBadField[n,fusion,inductionMatrix,traces];
-\[Infinity]]
],FusionPower[fusion][m,k][[1]]}
,
{m,1,Length[inductionMatrix]}];

(*Print[AllocateEigenvaluesToSimples[n,inductionMatrix]];*)
(*Print[cachedFrobeniusSchurIndicators[#\[LeftDoubleBracket]2\[RightDoubleBracket]][1]&/@AllocateEigenvaluesToSimples[n,inductionMatrix]];*)
pairs=Map[{#,Table[verifyFrobeniusSchurIndicators[#[[2]]][k],{k,1,k0}]}&,
Cases[
allocated, 
a_/;cachedFrobeniusSchurIndicators[a[[2]]][1]==UnitVector[Length[inductionMatrix],1]
]
];
(*Print[pairs];*)
Cases[pairs,{x_,v_}/;Union[#.{1,-1}&/@Flatten[v,1]]==={0}:>x]
];
GZIP[result,filename];
Print["Found ",Length[result], " T-matrices with good Frobenius-Schur indicators for ",DisplayGraph[fusion], " ",MatrixForm[inductionMatrix]];
(*Print[TableForm[#]]&/@result;*)
result]
]


(* ::Input::Initialization:: *)
(*Progress[fusion_,induction_]:=FileNames[ToFileName[{dataDirectory,"*","*"<>SHA1[induction]<>"*"}]]~Join~FileNames[ToFileName[{dataDirectory,"*","*"<>SHA1[{fusion,induction}]<>"*"}]]*)


(* ::Input::Initialization:: *)
(*StillTodo[fusion_,induction_]:=Complement[PossibleConductors[induction],ToExpression[StringSplit[StringSplit[#,"/"]\[LeftDoubleBracket]-1\[RightDoubleBracket],","]\[LeftDoubleBracket]1\[RightDoubleBracket]]&/@Cases[Progress[fusion,induction],s_/;!StringFreeQ[s,"allocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators"]]]*)


(* ::Input::Initialization:: *)
Clear[PartialGaloisAction]


(* ::Input::Initialization:: *)
PartialGaloisAction[n_Integer,induction_?MatrixQ]:=PartialGaloisAction[Table[l->PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,induction],l],{l,GaloisGroup[n]}],EquivalenceClassesOfSimples[induction]]
PartialGaloisAction[n_Integer,induction_?MatrixQ,eigenvalues_List]:=PartialGaloisAction[Table[l->PossibleGaloisImages[n,DimensionsFromInductionMatrix[n,induction],eigenvalues,l],{l,GaloisGroup[n]}],EquivalenceClassesOfSimples[induction,eigenvalues]]


(* ::Input::Initialization:: *)
SplitSymmetries[pga_PartialGaloisAction,ks:{__Integer}]:=ReplacePart[pga,2->SortBy[DeleteCases[Flatten[{Intersection[#,ks],Complement[#,ks]}&/@pga[[2]],1],{}],#[[1]]&]]


(* ::Input::Initialization:: *)
Clear[RefinePartialGaloisAction]


(* ::Input::Initialization:: *)
RefinePartialGaloisAction[n_,pga_PartialGaloisAction]:=Module[{targets,l,k},
(* look for a Galois element which isn't determined yet. *)
targets=Position[pga[[1]],images_/;Length[images]>1,{3}];
targets=SortBy[targets,!MemberQ[GaloisGroupGenerators[n],GaloisGroup[n][[#[[1]]]]]&];
If[Length[targets]==0,
(* we're done! *)
{GaloisAction[pga[[1]]/.list:{{_Integer}..}:>Flatten[list],pga[[2]]]},
l=GaloisGroup[n][[targets[[1,1]]]];
k=targets[[1,3]];
lastPartialGaloisAction=RefinePartialGaloisAction[n,SplitSymmetries[pga,{k}],l,k]
]
]


(* ::Input::Initialization:: *)
RefinePartialGaloisAction[n_,pga_PartialGaloisAction,l_Integer,k_Integer]:=Module[{images},
(* okay, decide where l sends k *)
images=(l/.pga[[1]])[[k]];
(* make use of symmetries: *)
images=DeleteCases[Intersection[images,#]&/@pga[[2]],{}][[All,1]];
Join@@(RefinePartialGaloisAction[n,SplitSymmetries[pga,{#}],l,k,{#}]&/@images)
]


(* ::Input::Initialization:: *)
RefinePartialGaloisAction[n_,pga_PartialGaloisAction,l_Integer,k_Integer,ms0:{}]:={}


(* ::Input::Initialization:: *)
RefinePartialGaloisAction[n_,pga_PartialGaloisAction,l_Integer,k_Integer,ms0:{__Integer}]:=Module[{ms,result,updateResult,rank},
If[Length[Complement[(l/.pga[[1]])[[k]],ms0]]==0,
(* No new information *)
{pga},
ms=Intersection[ms0,(l/.pga[[1]])[[k]]];
If[Length[ms]==0,
{},
result=pga/.(l->images_):>(l->ReplacePart[If[Length[ms]==1,Complement[#,ms]&/@images,images],k->ms]);
(* And now we should propagate information to all other Galois elements *)
result=EnforcePartialGaloisActionInverses[n,result,l,k];
rank=Length[pga[[1,1,2]]];
(*result=Fold[EnforcePartialGaloisActionConsistency[n,#1,#2\[LeftDoubleBracket]1\[RightDoubleBracket],l,#2\[LeftDoubleBracket]2\[RightDoubleBracket]]&,{result},Flatten[Outer[List,GaloisGroup[n],Range[rank]],1]];*)
updateResult[r_]:=Fold[EnforcePartialGaloisActionConsistency[n,#1,#2,l,k]&,r,GaloisGroup[n]];
result=FixedPoint[updateResult,result];
result
]
]
]


(* ::Input::Initialization:: *)
(* if we know a(k) exactly, we know a^{-1}(a(k)) *)
EnforcePartialGaloisActionInverses[n_,pgas_List,a_Integer,k_Integer]:=Join@@(EnforcePartialGaloisActionInverses[n,#,a,k]&/@pgas)
EnforcePartialGaloisActionInverses[n_,pga_PartialGaloisAction,a_Integer,k_Integer]:=Module[{},
If[Length[(a/.pga[[1]])[[k]]]==1,
RefinePartialGaloisAction[n,pga,GaloisInverse[n][a],(a/.pga[[1]])[[k,1]],{k}],
{pga}
]
]
(* (ab)(k) must be a subset of a(b(k)) *)EnforcePartialGaloisActionConsistency[n_,pgas_List,a_Integer,b_Integer,k_Integer]:=Join@@(EnforcePartialGaloisActionConsistency[n,#,a,b,k]&/@pgas)
EnforcePartialGaloisActionConsistency[n_,pga_PartialGaloisAction,a_Integer,b_Integer,k_Integer]:=Module[{targets},
targets=Intersection[
Union[Flatten[(a/.pga[[1]])[[#]]&/@((b/.pga[[1]])[[k]])]],
Union[Flatten[(b/.pga[[1]])[[#]]&/@((a/.pga[[1]])[[k]])]]
];
RefinePartialGaloisAction[n,pga,Mod[a b,n],k,targets]
]


(* ::Input::Initialization:: *)
Clear[CompletePartialGaloisAction]


(* ::Input::Initialization:: *)
CompletePartialGaloisAction[n_,pga_PartialGaloisAction]:=Module[{f},
f[p_PartialGaloisAction]:=f/@RefinePartialGaloisAction[n,p];
f[ga_GaloisAction]:={ga};
Flatten[f[pga]]
]


(* ::Input::Initialization:: *)
mkString[x_List,sep_]:=StringJoin@@(ToString/@Most[Flatten[Transpose[{x,Table[sep,{Length[x]}]}]]])


(* ::Input::Initialization:: *)
DreadnautPath="~/bin/dreadnaut";


(* ::Input::Initialization:: *)
NautyHash[ga_GaloisAction]:=Module[{G,X,preamble,edges,partition,cmd,return},
G=Length[ga[[1]]];
X=Length[1/.ga[[1]]];
preamble="c\nn="<>ToString[(G+2)X]<>" g\n";
edges=(StringJoin@@Table[(StringJoin@@Table[ToString[x+(g+1)X]<>" ",{g,0,G-1}])<>";\n",{x,0,X-1}])<>
(StringJoin@@Table[ToString[x]<>" "<>(StringJoin@@Table[ToString[(ga[[1,g+1,1]]/.ga[[1]])[[x+1]]-1+(g+1)X]<>" ",{g,0,G-1}])<>";\n",{x,0,X-1}])<>".\n";
partition="f=["<>mkString[mkString[#,","]&/@ga[[2]],"|"]<>"]\n";
cmd="x z\n";
return=Run[DreadnautPath<>" <<STOP > /tmp/dreadnaut"<>ToString[$KernelID]<>".out\n"<>preamble<>edges<>partition<>cmd<>"STOP"];
If[return!=0,
Print["Something went wrong while running dreadnaut. Please check you have a copy of dreadnaut, and modify FusionAtlas`ModularData`Private`DreadnautPath if necessary."];
];
"["<>StringJoin@@(StringSplit[StringSplit[Import["/tmp/dreadnaut"<>ToString[$KernelID]<>".out"],"\n"][[-1]]," "][[{2,3}]])
]


(* ::Input::Initialization:: *)
CompleteGaloisActions[n_,induction_]:=CompleteGaloisActions[n,induction]=Module[{outputDirectory,filename,result},
outputDirectory=FileNameJoin[{dataDirectory,"completeGaloisActions"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>SHA1[induction]<>".m.gz"}];
If[FileExistsQ[filename],
ImportGZIP[filename],
result=Normal[GroupBy[CompletePartialGaloisAction[n,PartialGaloisAction[n,induction]],NautyHash]][[All,2,1]];
GZIP[result,filename];
result
]
]
CompleteGaloisActions[n_,induction_,eigenvalues_]:=CompleteGaloisActions[n,induction,eigenvalues]=Normal[GroupBy[CompletePartialGaloisAction[n,PartialGaloisAction[n,induction,eigenvalues]],NautyHash]][[All,2,1]]


(* ::Input::Initialization:: *)
GaloisSubgroups[n_]:=GaloisSubgroups[n]=Module[{oneStepClosure,closure,extensions},
oneStepClosure[elements_List]:=Union@@Outer[Mod[#1 #2,n]&,elements,elements];
closure[elements_List]:=FixedPoint[oneStepClosure,elements];
extensions[elements_List]:=({elements}~Join~(closure/@(elements~Join~{#}&/@Complement[GaloisGroup[n],elements])));
FixedPoint[Union@@(extensions/@#)&,{{1}}]
]


(* ::Input::Initialization:: *)
GaloisSubgroups[n_,subgroup_]:=Cases[GaloisSubgroups[n],G_/;Length[Complement[G,subgroup]]==0]


(* ::Input::Initialization:: *)
GaloisEigenvalueStabilizer[n_,t_]:=Cases[GaloisGroup[n],l_/;Mod[(l^2-1)t,1]==0]


(* ::Input::Initialization:: *)
GaloisDimensionStabilizer[n_,d_]:=Cases[GaloisGroup[n],l_/;Abs[GaloisAction[n][l][d]]==d]


(* ::Input::Initialization:: *)
GaloisStabilizer[n_,{d_,t_}]:=GaloisStabilizer[n,{d,t}]=Cases[GaloisGroup[n],l_/;Mod[(l^2-1)t,1]==0\[And]Abs[GaloisAction[n][l][d]]==d]


(* ::Input::Initialization:: *)
StabilizerSubgroupMultiplicities[n_,subgroup_,totalSize_]:=StabilizerSubgroupMultiplicities[n,subgroup,totalSize]=Module[{subgroups=GaloisSubgroups[n,subgroup],max},
Flatten[Table[Table[a[i],{i,1,Length[subgroups]}],
Evaluate[Sequence@@Table[(max=(totalSize-Sum[a[j]Length[subgroup]/Length[subgroups[[j]]],{j,1,i-1}])Length[subgroups[[i]]]/Length[subgroup];{a[i],If[i==Length[subgroups],Ceiling[max],0],max}),{i,1,Length[subgroups]}]]
],Length[subgroups]-1]
]


(* ::Input::Initialization:: *)
BallsInUrns[urns_,{redBalls_,otherBalls___}]:=Module[{totalUrns,iterators,max,redDistributions,newUrns},
totalUrns=Total[urns[[All,2]]];
iterators=Flatten[Table[(max=redBalls-Sum[Sum[r[i0,j0],{j0,1,If[i0==i,j-1,urns[[i0,2]]]}],{i0,1,i}];{r[i,j],If[i==Length[urns]\[And]j==urns[[i,2]],max,0],Min[max,urns[[i,1]],If[j>1,r[i,j-1],\[Infinity]]]}),{i,1,Length[urns]},{j,1,urns[[i,2]]}],1];
(*Print[iterators];*)
redDistributions=Flatten[
Table[Flatten[Table[r[i,j],{i,1,Length[urns]},{j,1,urns[[i,2]]}]],Evaluate[Sequence@@iterators]],
totalUrns-1
];
(*Print[redDistributions];*)
newUrns[distribution_]:={#[[1,1,2]]-#[[1,2]],Length[#]}&/@Split[Transpose[{Flatten[Table[Table[{i,urns[[i,1]]},{urns[[i,2]]}],{i,1,Length[urns]}],1],distribution}]];
Flatten[Function[redDistribution,{redDistribution}~Join~#&/@BallsInUrns[newUrns[redDistribution],{otherBalls}]]/@redDistributions,1]
]


(* ::Input::Initialization:: *)
BallsInUrns[{{0,_}...},{}]:={{}}
BallsInUrns[urnSizes_,{}]:={}


(* ::Input::Initialization:: *)
GaloisOrbitOfInvariant[n_,{d_,t_}]:=Union[Table[{Abs[GaloisAction[n][l][d]],Mod[l^2 t,1]},{l,GaloisGroup[n]}]]


(* ::Input::Initialization:: *)
Unprotect[Abs];
Abs[x_AlgebraicNumber]/;cachedRootReduce[Im[x]]===0:=If[Chop[N[x]]>=0,x,-x]
Protect[Abs];


(* ::Input::Initialization:: *)
PartitionObjectsByInvariants[n_,induction_,T_]:=Module[{\[ScriptCapitalD],dims,pairs,indices},
{\[ScriptCapitalD],dims}=DimensionsFromInductionMatrix[n,induction];
pairs=Transpose[{dims/\[ScriptCapitalD],T}];
indices[{d_,t_}]:={d,t}->Table[Flatten[Position[Transpose[{pairs,Transpose[induction]}],{{d,t},c}]],{c,Union[Transpose[induction]]}];
Map[indices,Union[(GaloisOrbitOfInvariant[n,#]&/@pairs)],{2}]
]


(* ::Input::Initialization:: *)
StabilizerActions[n_,induction_,orbit:{{d_,t_}->objects1_,others___}]:=Module[{subgroups,cosetSizes,multiplicities,howManyInEachCoset,objectsInCosets},
subgroups=GaloisSubgroups[n,GaloisStabilizer[n,{d,t}]];
cosetSizes=Length[GaloisStabilizer[n,{d,t}]]/(Length/@subgroups);
multiplicities=StabilizerSubgroupMultiplicities[n,GaloisStabilizer[n,{d,t}],Length[Flatten[objects1]]];
howManyInEachCoset=Flatten[Function[m,{m,#}&/@Flatten[Outer[List,Sequence@@Table[BallsInUrns[Transpose[{cosetSizes,m}],Length/@objects],{objects,orbit[[All,2]]}],1],Length[orbit]-1]]/@multiplicities,1];
objectsInCosets[{multiplicities_,ballsInUrnsMatrices_}]:={Flatten[Table[Table[subgroups[[i]],{multiplicities[[i]]}],{i,1,Length[multiplicities]}],1],Table[orbit[[l,1]]->Table[Join@@Table[orbit[[l,2,i,(Total[ballsInUrnsMatrices[[l,i,1;;j-1]]]+1);;Total[ballsInUrnsMatrices[[l,i,1;;j]]]]],{i,1,Length[ballsInUrnsMatrices[[l]]]}],{j,1,Length[ballsInUrnsMatrices[[l,1]]]}],{l,1,Length[orbit]}]};
objectsInCosets/@howManyInEachCoset
]


(* ::Input::Initialization:: *)
StabilizerActions[n_,induction_,T_]:=Module[{orbits},
orbits=PartitionObjectsByInvariants[n,induction,T];
Flatten[Outer[List,Sequence@@(StabilizerActions[n,induction,#]&/@orbits),1],Length[orbits]-1]
]


(* ::Input::Initialization:: *)
GaloisSubgroupSplittings[n_,subgroup_]:=GaloisSubgroupSplittings[n,subgroup]=
Cases[
Cases[GaloisSubgroups[n],G_/;Length[G]Length[subgroup]==Length[GaloisGroup[n]]:>{G,Mod[Outer[Times,subgroup,G],n]}],
({G_,products_}/;(Union[Flatten[products]]==GaloisGroup[n])):>Table[l->Cases[products,p_/;MemberQ[p,l]:>Intersection[p,subgroup][[1]],1,1][[1]],{l,GaloisGroup[n]}]]


(* ::Input::Initialization:: *)
GaloisSubgroupSplittings[n_]:=GaloisSubgroupSplittings[n,#]&/@GaloisSubgroups[n]


(* ::Input::Initialization:: *)
(* H a subgroup of K a subgroup of Gal(n) *)
GaloisCosets[n_,H_,K_]:=GaloisCosets[n,H,K]=Union[Union/@Mod[H #&/@K,n]]


(* ::Input::Initialization:: *)
GaloisActionFromStabilizerAction[n_,induction_,action_]:=Table[(*Print[l];*)l->Table[(*Print[i];*)
Module[{orbit,indexInOrbit,coset,indexInCoset,imageIndexInOrbit,imageIndexInCoset,stabilizer,splitting,imageInStabilizer,cosets},
{orbit,indexInOrbit,coset,indexInCoset}=Position[action,i,{6}][[1,{1,3,5,6}]];
imageIndexInOrbit=Position[action[[orbit,2,All,1]],{Abs[GaloisAction[n][l][action[[orbit,2,indexInOrbit,1,1]]]],Mod[l^2 action[[orbit,2,indexInOrbit,1,2]],1]}][[1,1]];
(*Print["{orbit,indexInOrbit,coset,indexInCoset},imageIndexInOrbit=",{orbit,indexInOrbit,coset,indexInCoset},imageIndexInOrbit];*)
stabilizer=GaloisStabilizer[n,action[[orbit,2,1,1]]];
(*If[Length[GaloisSubgroupSplittings[n,stabilizer]]\[Equal]0,
Print["Stabilizer subgroup of ",action\[LeftDoubleBracket]orbit,2,1,1\[RightDoubleBracket]," (with conductor ",n,") isn't complemented! Tell Scott about this example, and ask him to write a better algorithm."];
Abort[];
];*)
(*splitting=GaloisSubgroupSplittings[n,stabilizer]\[LeftDoubleBracket]1\[RightDoubleBracket];
imageInStabilizer=l/.splitting;*)
(*Print["splitting=",splitting];*)
cosets=GaloisCosets[n,action[[orbit,1,coset]],Union[Mod[l stabilizer,n]]];
(*
Print["imageInStabilizer=",imageInStabilizer];
Print["stabilizer=",stabilizer];
Print["cosets=",cosets];
Print[Sort[Mod[imageInStabilizer cosets\[LeftDoubleBracket]indexInCoset\[RightDoubleBracket],n]]];
*)
imageIndexInCoset=Position[cosets,Sort[Mod[l GaloisCosets[n,action[[orbit,1,coset]],stabilizer][[indexInCoset]],n]],1,1][[1,1]];
action[[orbit,2,imageIndexInOrbit,2,coset,imageIndexInCoset]]
]
,{i,1,Length[induction[[1]]]}]
,{l,GaloisGroup[n]}]


(* ::Input::Initialization:: *)
CompleteGaloisActions2[n_,induction_,eigenvalues_]:=verifyGaloisAction[n,induction,eigenvalues][GaloisAction[GaloisActionFromStabilizerAction[n,induction,#]]]&/@StabilizerActions[n,induction,eigenvalues]
verifyGaloisAction[n_,induction_,eigenvalues_][GaloisAction[ga_]]:=Module[{dims,S1},
dims=DimensionsFromInductionMatrix[n,induction];
S1=dims[[2]]/dims[[1]];
Do[
If[Mod[l^2 eigenvalues,1]=!=eigenvalues[[l/.ga]],
Print["Bad Galois action on eigenvalues for l = ",l];
Print["eigenvalues = ",eigenvalues];
Print[Mod[l^2 eigenvalues,1]];
Print[eigenvalues[[InversePermutation[l/.ga]]]];
Print[ga];
Abort[]
];
If[Abs[GaloisAction[n][l]/@S1]=!=S1[[l/.ga]],
Print["Bad Galois action on dimensions for l = ",l];
Print["S1 = ",Chop[N[S1]]];
Print["eigenvalues = ",eigenvalues];
Print[ga];
Abort[]
];
,{l,GaloisGroup[n]}];
GaloisAction[ga]
]


(* ::Input::Initialization:: *)
AllocateEigenvaluesToSimplesAndCompleteGaloisActions[n_,fusion_,k_,induction_]:=Module[{filename,outputDirectory,result},
outputDirectory=FileNameJoin[{dataDirectory,"allocateEigenvaluesToSimplesAndCompleteGaloisActions"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>ToString[k]<>","<>SHA1[{fusion,induction}]<>".m.gz"}];
If[(*False\[And]*)FileExistsQ[filename],
ImportGZIP[filename],
Print["Computing Galois actions for ",DisplayGraph[fusion]," ",MatrixForm[induction]];
result=Join@@Map[Function[ga,{#,ga}]/@CompleteGaloisActions2[n,induction,#[[2]]]&,AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators[n,fusion,k,induction]];
GZIP[result,filename];
Print[" ... finished computing Galois actions."];
result]
]


(* ::Input::Initialization:: *)
CalculateGaloisSigns[n_Integer,inductionMatrix_,ga_GaloisAction]:=Module[{S1,dims=DimensionsFromInductionMatrix[n,inductionMatrix],signs},
S1=dims[[2]]/dims[[1]];
signs[l_->permutation_]:=l->(permutation verifySigns[((GaloisAction[n][l]/@S1)/S1[[permutation]]),ga]);
SignedGaloisAction[signs/@ga[[1]]]
]
verifySigns[stuff_,ga_]:=(If[Complement[stuff,{1,-1}]=!={},Print["Something went wrong calculating Galois signs for: ", ga];Abort[]];stuff)


(* ::Input::Initialization:: *)
(*SignedPermutationMatrix[signedPermutation_]:=IdentityMatrix[Length[signedPermutation]]\[LeftDoubleBracket]Abs[signedPermutation]\[RightDoubleBracket]Sign[signedPermutation]*)


(* ::Input::Initialization:: *)
SignedPermutationMatrix[signedPermutation_]:=Table[Sign[signedPermutation[[i]]]KroneckerDelta[j,Abs[signedPermutation[[i]]]],{i,1,Length[signedPermutation]},{j,1,Length[signedPermutation]}]


(* ::Input::Initialization:: *)
QLinearSolutions[n_Integer,inductionMatrix_][{{Vs_,Ts_},ga_}]:=Module[{Q,q,sga,dims,S1,T,tEquations,modularInvariantEquations,galoisEquations,galoisOnSEquations,C,S2eqCEquations,inductionEquations,equations,Tp,Sp,result},
Print["Preparing the linear equations for the change of basis matrix..."];
Q=Table[q[i,j],{i,1,Length[inductionMatrix[[1]]]},{j,1,Length[inductionMatrix[[1]]]}];
Tp=TInRepresentation[n,Vs[[All,1]]];
Sp=SInRepresentation[n,Vs[[All,1]]];
T=DiagonalMatrix[Power[\[Zeta][n],n Ts]];
tEquations={Tp.Q-Q.T};
(*Print["prepared tEquations"];*)
modularInvariantEquations={Sp.Q.inductionMatrix[[1]]-Q.inductionMatrix[[1]]};
(*Print["prepared modularInvariantEquations"];*)
If[ga=!=Null,
sga=CalculateGaloisSigns[n,inductionMatrix,ga];
galoisEquations=Table[GaloisInRepresentation[n,Vs[[All,1]],p[[1]]].Q-Q.SignedPermutationMatrix[p[[2]]],{p,sga[[1]]}];
(*Print["prepared galoisEquations"];*)
dims=DimensionsFromInductionMatrix[n,inductionMatrix];
S1=dims[[2]]/dims[[1]];
(* TODO try uncommenting the second half of this one! *)
galoisOnSEquations=Collect[
Table[(Sp.Q)[[All,Abs[p[[2,1]]]]]-(Q.(Sign[p[[2,1]]](GaloisAction[n][p[[1]]]/@S1))),{p,sga[[1]]}](*~Join~
Table[(Sp.Q)\[LeftDoubleBracket]All,1\[RightDoubleBracket]-(Q.(Sign[p\[LeftDoubleBracket]2\[RightDoubleBracket]](GaloisAction[n][PowerMod[p\[LeftDoubleBracket]1\[RightDoubleBracket],-1,n]]/@S1\[LeftDoubleBracket]InversePermutation[p\[LeftDoubleBracket]2\[RightDoubleBracket]]\[RightDoubleBracket]))),{p,sga\[LeftDoubleBracket]1\[RightDoubleBracket]}]*),_q];
(*Print["prepared galoisOnSEquations"];*)
(*Print[Flatten[galoisOnSEquations]];*)
C=IdentityMatrix[Length[inductionMatrix[[1]]]][[n-1/.ga[[1]]]];
S2eqCEquations={Sp.Sp.Q-Q.C};,
galoisEquations=galoisOnSEquations=S2eqCEquations={};
];
(*A^t=TS^{-1}T A^{t}*)
(*S T^(-1) A^t = T A^t*)
(*S' Q T^(-1) A^t = Q T A^t*)
inductionEquations={Sp.Q.T.Transpose[inductionMatrix]-Q.Inverse[T].Transpose[inductionMatrix]};
lastLinearEquations={tEquations,modularInvariantEquations,galoisEquations,galoisOnSEquations,S2eqCEquations,inductionEquations};
equations=Collect[LiftToCommonCyclotomicField[Flatten[tEquations~Join~modularInvariantEquations~Join~galoisEquations~Join~galoisOnSEquations~Join~S2eqCEquations~Join~inductionEquations]],_q];
(*Print["prepared linear equations in Q"];*)
Print["Preparing to solve linear equations for the change of basis matrix..."];
Check[
result=Q/.Solve[equations==0][[1]],
Print["Something went wrong: here are the equations."];
Print[tEquations];
Print[modularInvariantEquations];
Print[galoisEquations];
Print[galoisOnSEquations];
Print[S2eqCEquations];
Abort[];
];
Print["... finished solving linear equations in Q."];
Function[{q0},Evaluate[result/.q->q0]]
]


(* ::Input::Initialization:: *)
timesToList[X_Times]:=List@@X
timesToList[X_]:={X}


(* ::Input::Initialization:: *)
AlgebraicDegree[eqn_,vars_List]:=Max[Total[GroebnerBasis`DistributedTermsList[eqn/.Equal:>Subtract,vars][[1,All,1]],{2}]]
AlgebraicDegree[eqn_]:=AlgebraicDegree[eqn,Variables[eqn]]


(* ::Input::Initialization:: *)
SolveSEquations[n_Integer,inductionMatrix_][Vs_,ga_,Q0_]:=Module[{S,Sp,Q,s,q,dims, S1,C,equations,det,det0,variables,targets,target,\[Alpha],result,solutions},
Sp=SInRepresentation[n,Vs];
S=Table[s[Min[i,j],Max[i,j]],{i,1,Length[inductionMatrix[[1]]]},{j,1,Length[inductionMatrix[[1]]]}];
dims=DimensionsFromInductionMatrix[n,inductionMatrix];
S1=dims[[2]]/dims[[1]];
S[[1]]=S1;
S[[All,1]]=S1;
(*Print[Sp//MatrixForm];*)
(*Print[S//MatrixForm];*)
Q=Q0[q];
(*Print[Q//MatrixForm];*)
det0=Det[Q];
SetAttributes[report,HoldAll];
report[X_]:=Module[{r},Print["factoring determinant ..."];r=X;Print["done!"];r];
det:=(det0=report[Factor[Collect[det0,_q]]]);
variables:=Cases[timesToList[det],(v:q[_,_])^_.:>v];
equations=If[ga===Null,
{Sp.Q-Q.S},
(* it seems this equation has already been solved, in its linear version as Sp.Sp.Q=Qp.C *)
(* TODO try removing, and verifying everything(!) still works *)
C=IdentityMatrix[Length[inductionMatrix[[1]]]][[n-1/.ga[[1]]]];
{Sp.Q-Q.S,S.S-C}
];
equations=Factor[Collect[LiftToCommonCyclotomicField[Flatten[equations]],_q|_s]];
(*Print["found equations"];*)
While[Length[targets=Cases[equations,e_/;AlgebraicDegree[e]==1]~Join~Cases[equations,(Alternatives@@variables)X_:>X]]>0,
(*Print["solving: " ,targets];*)
Solve[targets==0]/.(x_->y_):>(x=y);
equations=Union[DeleteCases[Factor[Collect[equations,_q|_s]],0]];
];
If[Length[variables]>0,
target=SortBy[variables,Count[equations,#,\[Infinity]]&][[-1]];
(*Print["Setting ",target, " to 1"];*)
equations=equations~Join~{target-1};
While[Length[targets=Cases[equations,e_/;AlgebraicDegree[e]==1]~Join~Cases[equations,(Alternatives@@variables)X_:>X]]>0,
(*Print["solving: " ,targets];*)
Solve[targets==0]/.(x_->y_):>(x=y);
equations=Union[DeleteCases[Factor[Collect[equations,_q|_s]],0]];
];
];
Print["S matrix after solving linear equations:"];
Print[(S/.s->Global`s)//MatrixForm];
Print["Q matrix after solving linear equations:"];
Print[(Q/.q->Global`q)//MatrixForm];
(*Print[det/.{s\[Rule]Global`s,q\[Rule]Global`q}];*)
equations=equations~Join~{\[Alpha] det -1};
(*Print[equations/.{s\[Rule]Global`s,q\[Rule]Global`q}];*)
Print["About to start solving quadratic equations..."];
lastSEquations=equations;
solutions=Solve[equations==0];
Print["... done!"];
If[Length[solutions]==0,
Function[{q0,s0},{}],
result=S/.solutions;
Function[{q0,s0},Evaluate[result/.{q->q0,s->s0}]]
]
]


(* ::Input::Initialization:: *)
invertibleQ[m_]:=Module[{rules},
rules=(#->RandomInteger[{1000,2000}])&/@Variables[m];
If[Det[m/.rules]!=0,
True,
Factor[Det[m]]=!=0
]
]


(* ::Input::Initialization:: *)
FindQLinearSolutions[n_,fusion_,k_,inductionMatrix_,useGalois:(True|False):True]:=Module[{filename,outputDirectory,result,pairs,triples,pMap},
outputDirectory=FileNameJoin[{dataDirectory,"findQLinearSolutions"}];
If[!FileExistsQ[outputDirectory],CreateDirectory[outputDirectory]];
filename=FileNameJoin[{outputDirectory,ToString[n]<>","<>ToString[k]<>","<>SHA1[{fusion,inductionMatrix}]<>If[useGalois,"","-no-galois"]<>".m.gz"}];
If[(*False\[And]*)FileExistsQ[filename],
ImportGZIP[filename],
result=Module[{allocations,q},
allocations=If[useGalois,
AllocateEigenvaluesToSimplesAndCompleteGaloisActions[n,fusion,k,inductionMatrix],
{#,Null}&/@AllocateEigenvaluesToSimplesAndCheckFrobeniusSchurIndicators[n,fusion,k,inductionMatrix]
];
pMap=If[False\[And]$KernelID==0,DistributeDefinitions[QLinearSolutions,invertibleQ];ParallelMap,Map];
pairs=pMap[{#,QLinearSolutions[n,inductionMatrix][#]}&,allocations];
triples=pMap[{#,invertibleQ[#[[2]][q]]}&,pairs];
Cases[triples,{r_,True}:>r]
];
GZIP[result,filename];
result]
]


(* ::Input::Initialization:: *)
FindModularData[n_,fusion_,inductionMatrix_,k:_Integer:6,useGalois:(True|False):True]:=Module[{qsols=FindQLinearSolutions[n,fusion,k,inductionMatrix,useGalois],q,s},
Flatten[Map[(Function[S,{S,#[[1,1,2]]}]/@Union[SolveSEquations[n,inductionMatrix][#[[1,1,1,All,1]],#[[1,2]],#[[2]]][q,s]])&,qsols],1]
]


(* ::Input::Initialization:: *)
permuteColumns[inductionMatrix_]:=Transpose[SortBy[Transpose[inductionMatrix],{Total[#],Reverse[#]}&]]


(* ::Input::Initialization:: *)
FindModularData[fusion_,induction_?MatrixQ]:=
Module[{},
Print["Beginning calculation of modular data for ",DisplayGraph[fusion]," ",MatrixForm[induction]];
Print["Considering conductors: ",PossibleConductors[induction]];
Join@@Table[FindModularData[n,fusion,permuteColumns[induction],6],{n,PossibleConductors[induction]}]
]
FindModularData[fusion_,inductions:{___?MatrixQ}]:=Join@@(FindModularData[fusion,#]&/@inductions)
FindModularData[fusion_]:=FindModularData[fusion,InductionMatrices[fusion]]
FindModularData[g_GradedBigraph]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(EvenPartFusionRules/@FindFusionRules[g]);
Join@@(FindModularData@@#&/@Select[InductionMatrices[g],CheckGaloisVerlinde])
]
FindModularData[ m_?MatrixQ]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(FindFusionRules[m]);
Join@@(FindModularData/@FindFusionRules[m])
]
ParallelFindModularData[fusion_,inductions:{___?MatrixQ}]:=Module[{},
DistributeDefinitions[FindModularData,permuteColumns,PossibleConductors];
Flatten[ParallelTable[FindModularData[n,fusion,permuteColumns[induction],6],{induction,inductions},{n,PossibleConductors[induction]}]]
]
ParallelFindModularData[fusion_]:=ParallelFindModularData[fusion,InductionMatrices[fusion]]
ParallelFindModularData[g_GradedBigraph]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(EvenPartFusionRules/@FindFusionRules[g]);
Join@@(ParallelFindModularData@@#&/@Select[InductionMatrices[g],CheckGaloisVerlinde])
]
ParallelFindModularData[ m_?MatrixQ]:=Module[{},
Print["Considering fusion rings: "];
Print[DisplayGraph[#]]&/@(FindFusionRules[m]);
Join@@(ParallelFindModularData/@FindFusionRules[m])
]




(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
EndPackage[];
