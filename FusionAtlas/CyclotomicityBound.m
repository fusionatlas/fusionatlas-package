(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["FusionAtlas`CyclotomicityBound`",{"FusionAtlas`","FusionAtlas`Bigraphs`","FusionAtlas`GraphPairs`","FusionAtlas`Debugging`"}];


CyclotomicityBound::usage="CyclotomicityBound[g], where g is a GradedBigraph, returns an N so that all translates with rank greater than N can not have a cyclotomic index.";


CyclotomicTranslates::usage="CyclotomicTranslates[g], where g is a GradedBigraph or a pair of BigraphWithDuals, returns all translates of g with cyclotomic index";


CyclotomicTranslatesWithWitnesses::usage="CyclotomicTranslatesWithWitnesses[g], where g is a GradedBigraph, returns all translates of g with cyclotomic index, and a list of primes witnessing the non-cyclotomicity of all other translates allowed by CyclotomicityBound[g].";


Begin["`Private`"];


LowestPower[p_,q_]:=-Exponent[p,q,-#&]


HalfIfEven[n_Integer]:=If[Mod[n,2]==0,n/2,n];


FindFj[g_GradedBigraph,q_,j_]/;j==0\[Or]j==1:=FindFj[g,q,j]=Module[{x},Expand[(-1)^(GraphRank[g]+j)CharacteristicPolynomial[GraphAdjacencyMatrix[Translate[g,j]],x]/.x->(q+q^(-1))]]
FindFj[g_GradedBigraph,q_,j_]/;j>=2:=FindFj[g,q,j]=
Expand[(q+q^-1)FindFj[g,q,j-1]-FindFj[g,q,j-2]]


FindModifiedFj[g_GradedBigraph,q_,j_,spokes_:1]:=Expand[(q-q^(-1))^spokes FindFj[g,q,j]]


Clear[CheckACandidate]
CheckACandidate[g_GradedBigraph,candidate_,q_,spokes_:1]:=Module[{rank=GraphRank[g]},
(*Print[{Expand[q^rank candidate - q^(-rank)(candidate /. q\[Rule]q^(-1))],FindModifiedFj[g,q,0,spokes]}];*)
And[Expand[q^rank candidate - q^(-rank)(candidate /. q->q^(-1))]==FindModifiedFj[g,q,0,spokes],Expand[q^(rank+1) candidate - q^(-rank-1)(candidate /. q->q^(-1))]==FindModifiedFj[g,q,1,spokes]]
];


Clear[FindAands]
FindAands[g_GradedBigraph,q_,cylinder_:False] :=FindAands[g,q,cylinder] =
Module[{rank=GraphRank[g],n,oldcandidate=0,candidate,maxsteps=\[Infinity],spokes},
If[cylinder,spokes=1+RankAtDepth[g,GraphDepth[g]],spokes=1];
(*Print[spokes];*)
For[n=rank,n<=rank+maxsteps,n++,
If[Mod[n,100]==0,DebugPrint["Looking at rank ", n, " while finding A and s."]];
candidate = Expand[q^(-rank-n)( FindModifiedFj[g,q,n,spokes]/.q^(k_/;k<0)->0)];
(*Print[candidate];*)
If[And[candidate==oldcandidate,CheckACandidate[g,candidate,q,spokes]],Return[{candidate,Max[-LowestPower[candidate,q],0]+1}];];
oldcandidate=candidate;
];
(* Find A, then s is max{-(smallest exponent of A),0} +1 *)
Message["Not found.  Try more steps?"];
Return[$Failed];
];
FindA[g_GradedBigraph,q_] :=FindAands[g,q][[1]]
Finds[g_GradedBigraph] :=Module[{q},FindAands[g,q][[2]]]


(* Returns True if A has only one sign change, and False otherwise.  If True, this means that A is in the "Salem Case" *)
ASalemFormQ[g_GradedBigraph]:=Module[{q},ASalemFormQ[FindA[g,q],q]];
ASalemFormQ[A_,q_]:=SignChanges[A,q]==1;


(* Returns {l,B,C} where A(t)=t^(-l)B(t)C(t), B and C are polynomials, and B is a maximal self-reciprocal factor *)
FactorReciprocal[F_,q_]:=Module[{factorlist=FactorList[F],result,B,laurentC},
{B,laurentC}=(Times @@ Power @@@ # &) /@ GatherBy[factorlist,And[#[[2]]>0,ReciprocalPolynomialQ[#[[1]],q]]&];
{-LowestPower[laurentC,q],B,Expand[q^(-LowestPower[laurentC,q])laurentC]}
];


ReciprocalPolynomialQ[F_,q_]:=Module[{coefficientlist=CoefficientList[F,q],powerlist=Exponent[#,q]&/@ MonomialList[F]},
And[Or[coefficientlist==Reverse[coefficientlist],coefficientlist==-Reverse[coefficientlist]],powerlist==Exponent[F,q]-Reverse[powerlist]]
];


SignChanges[A_,q_]:=Length[Split[Select[CoefficientList[A*q^(Exponent[A,q,-#&]),q],#!=0&],#1*#2>0&]]-1


\[Zeta][n_]:=\[Zeta][n]=With[{p=Evaluate[Cyclotomic[n,#]]&},With[{d=Module[{m},Exponent[p[m],m]]},
AlgebraicNumber[Root[p,d],{0,1}~Join~Table[0,{d-2}]]]]


CouldBeRootOfUnity[z_,j_]:=Module[{precision,gap},
If[Abs[Abs[N[z]]-1]>0.001,
False,
precision=Max[2Ceiling[-Log[10,N[2\[Pi]/j]]]+10,20];
Quiet[Check[
gap=Abs[Mod[N[Arg[z]/(2\[Pi]/j),precision],1,-1/2]];
gap<10^(-3precision/4),
(* N::meprec occurs when Arg[z] is zero; it's always safe to return True here because someone double checks exactly afterwards. *)
True,
N::meprec
],N::meprec
]
]
]


BoundR1[A_,q_]:=Module[{B,C,l,m,length,s,kthrootbound,dividends,ks,k,zetak,r,goodk={},period,n,Breciprocalsign,R1BoundList,R1Bound},
DebugPrint["Entering BoundR1 with A = ",A];
{l,B,C}=FactorReciprocal[A,q];
Breciprocalsign=If[CoefficientList[B,q][[1]]/CoefficientList[B,q][[-1]]>0,1,-1];
DebugPrint["l = ",l];
DebugPrint["B = ",B];
DebugPrint["C = ",C];
DebugPrint["Breciprocalsign = ",Breciprocalsign];
m=Exponent[C,q];
length=Length[MonomialList[Expand[C]]];
s=Product[Prime[k],{k,1,PrimePi[2*length]}];
kthrootbound=2*s*m;
dividends=Table[j*s,{j,1,4*m}];
DebugPrint["Upper bound on k for primitive kth root of unity to be a root is ",kthrootbound];

ks=Cases[Union@@(Divisors/@dividends),k_/;3<=k<=kthrootbound];
Do[
If[Mod[i,20]==0,DebugPrint["checked ",i," of ",Length[ks]," possible roots of unity."]];
k=ks[[i]];
zetak=Exp[2\[Pi] I/k];
r=(C/.q->zetak^-1)/(C/.q->zetak);
If[CouldBeRootOfUnity[r,2k],
DebugPrint["\[Zeta][",k,"] has a chance at being a root of some F_n"];
zetak=\[Zeta][k];
r=(C/.q->zetak^-1)/(C/.q->zetak);
If[r^(2k)-1==0,
For[n=1,n<=HalfIfEven[k],n+=1,
If[r-Breciprocalsign * zetak^(2(n-l)+Exponent[B,q])==0,
DebugPrint["\[Zeta][",k,"]^",n," is a root of F",n];
goodk=Union[goodk,{{k,n}}]];
];
];
];
,{i,Length[ks]}];

period =HalfIfEven[LCM @@ goodk[[All,1]]];

R1BoundList=1/2*(Total[(Exponent[Cyclotomic[#[[1]],q],q] &)/@ #]&) /@ Table[Select[goodk,Mod[2*#[[2]]-2*p,#[[1]]]==0&],{p,1,period}]+GetRForBRootsOfUnity[B,q];
R1Bound=Max@@R1BoundList;
DebugPrint["|R1| achieves its maximum ",R1Bound," at P",Select[Range[1,Length[R1BoundList]],R1BoundList[[#]]==R1Bound&,1][[1]],"."];
R1Bound
];


GetRForB[B_,q_]:=Module[{roots=q/.Solve[B==0,q],roottally,rootsofunity,nonrootsofunity,Rforrootsofunity,Rfornonrootsofunity},
If[Not[ListQ[roots]],Return[{0,0}]]; (* B is constant *)
roottally=Tally[roots];
nonrootsofunity=Select[roottally,Not[RootOfUnityQ[#[[1]]]]&];
rootsofunity=Select[roottally,RootOfUnityQ[#[[1]]]&];
(* Count roots of unity besides \[PlusMinus]1 as half, to account for complex conjugate *)
Rforrootsofunity=Fold[#1+If[Or[#2[[1]]==1,#2[[1]]==-1],#2[[2]],#2[[2]]/2]&,0,rootsofunity];
Rfornonrootsofunity=Fold[#1+If[#2[[2]]>1,#2[[2]],0]&,0,nonrootsofunity];
{Rforrootsofunity,Rfornonrootsofunity}
];
GetRForBRootsOfUnity[B_,q_]:=GetRForB[B,q][[1]];
GetRForBRepeatedRoots[B_,q_]:=GetRForB[B,q][[2]];


Clear[BoundR]
BoundR[g_GradedBigraph]:=BoundR[g]=
Module[{A,l,B,C,q,R1Bound,R2BoundCircle,R2BoundLine,RBound,N},
q=Global`q;
DebugPrint["Entering BoundR."];
A=FindA[g,q];
{l,B,C}=FactorReciprocal[A,q];
R1Bound=BoundR1[A,q];
If[SignChanges[A,q]==1,Return[R1Bound];];
R2BoundCircle=GetRForBRepeatedRoots[B,q];
R2BoundLine=2SignChanges[A,q]+1 ;
RBound=R1Bound+R2BoundCircle+R2BoundLine;
DebugPrint["|R| bound is ",RBound];
RBound
];


FindKGamma[g_GradedBigraph]:=FindKGamma[g]=Module[{polyList,q},polyList=#[[1]]^#[[2]]&/@FactorList[FindFj[g,q,Max[0,Finds[g]-GraphRank[g]]]];
Round[Total[DeleteCases[Flatten[(q/.NSolve[#==0,q]&)/@polyList],q]^4]]]


DerivativeFunction[g_GradedBigraph,n_,q_]:=Module[{A,l,B,C,s},
{A,s}=FindAands[g,q];
{l,B,C}=FactorReciprocal[A,q];
2(n-l) Abs[Expand[C]]-Abs[Expand[D[C,q]]]-Abs[Expand[D[C/.(q->q^(-1)),q]]]
];


VerifyBoundLargeEnoughForDerivatives[g_GradedBigraph,n_]:=VerifyBoundLargeEnoughForDerivates[g,n]=Module[{},
DebugPrint["running Reduce to check derivatives ..."];
Reduce[{(DerivativeFunction[g,n,q]/.q->Exp[I \[Theta]]/.Abs[x_]:>Sqrt[ExpToTrig[Expand[x (x/.\[Theta]:>-\[Theta])]]])<0,0<=\[Theta]<=2\[Pi]}]===False
]


CyclotomicityBound[g_GradedBigraph]:=CyclotomicityBound[g]=Module[{q,KGamma,RBound,N,s,result},
DebugPrint["Entering CyclotomicityBound with g = ",GraphToString[g]];
KGamma=FindKGamma[g];
s=Finds[g];
RBound=BoundR[g];
N = 4*KGamma + 9*RBound;
DebugPrint["K(\[CapitalGamma]): ",KGamma,". |R|\[LessEqual]",RBound,". N=",N,". s=",s,"."];
result=Max[4*KGamma+9*RBound,s];
If[!ASalemFormQ[g],
While[!VerifyBoundLargeEnoughForDerivatives[g,result],
DebugPrint["Increasing the bound, as the derivative isn't positive yet: ",result];
result+=10]
];
result
];


RemoveFactors[polynomial_,factors_List,x_]:=Fold[RemoveFactor[#1,#2,x]&,polynomial,factors];
RemoveFactorOnce[polynomial_,factor_,x_]:=If[Exponent[factor,x]==0,polynomial,
PolynomialQuotientRemainder[polynomial,factor,x]/.{q_,0}:>q/.{_,_}:>polynomial];
RemoveFactor[polynomial_,factor_,x_]:=FixedPoint[RemoveFactorOnce[#,factor,x]&,polynomial];


adaptiveN[r_Root]:=Module[{n1,n2,x},
n1=Max[Log[10,Abs[CoefficientList[r[[1]][x],x]]]];
n2=Exponent[r[[1]][x],x];
N[r,2(n1+n2+10)]
]


magmaOut=FileNameJoin[{"/tmp","magma.out"}]


MagmaIsIrreducible[p_,x_Symbol]:=MagmaIsIrreducible[p,x]=Module[{magmaCommand,command,result},
magmaCommand="Q := RationalField(); P<q> := PolynomialRing(Q); f := "<>ToString[p/.x->Global`q,InputForm]<>"; IsIrreducible(f);";
command="echo '"<>magmaCommand<>"' | /Users/scott/bin/orac /usr/local/bin/magma | tail -n +3 > "<>magmaOut;
Run[command];
result=StringTrim[StringReplace[Import[magmaOut],"\n"~~___:>""]];
result=result/.{"true"->True,"false"->False};
If[result=!=True\[And]result=!=False,Print["Something went wrong processing the Magma output!"];Abort[]];
result
]


IrreducibleQ[p_,x_]:=If[Exponent[p,x]>200,
DebugPrint["Calling magma on orac to check irreducibiliity."];
MagmaIsIrreducible[p,x],
IrreduciblePolynomialQ[p]
]


GetMinimalPolynomialList[g_GradedBigraph,maxVertices_Integer,x_]:=GetMinimalPolynomialList[g,maxVertices,x]=Module[{characteristicPolynomial,minimalPolynomialGuess,minimalPolynomial,divisors,newDivisors,result,results},
(* We compute the characteristic polynomials of the adjacency matrix via the recursion. *)
characteristicPolynomial[k_]:=characteristicPolynomial[k]=Expand[-x characteristicPolynomial[k-1]-characteristicPolynomial[k-2]];
characteristicPolynomial[t:0|1]:=CharacteristicPolynomial[GraphAdjacencyMatrix[Translate[g,t]],x];
minimalPolynomialGuess[k_]:=RemoveFactors[characteristicPolynomial[k],divisors,x];
divisors={};
minimalPolynomial[k_]:=minimalPolynomial[k]=MinimalPolynomial[DimensionOfGenerator[Translate[g,k]]][x];
DebugPrint["About to start computing minimal polynomials up to ",maxVertices," vertices for ",g];
results=Table[
If[Mod[t,20]==0,DebugPrint["Finding minimal polynomial for graph with ",GraphRank[g]+t," vertices: checking ", minimalPolynomialGuess[t]/.x->Global`q];];
If[IrreducibleQ[minimalPolynomialGuess[t],x],
minimalPolynomial[t]=minimalPolynomialGuess[t],
newDivisors=Complement[FactorList[characteristicPolynomial[t]/minimalPolynomial[t]][[All,1]],divisors];
DebugPrint["Found new divisors: ",newDivisors/.x->Global`q];
divisors=Union[divisors~Join~newDivisors]
];
(* We've now calculated the minimal polynomial of the square root of the index. *)
(* If the minimal polynomial of the square root of the index is an even polynomial, dividing all the exponents by 2 must give the minimal polynomial of the index. *)
If[And@@(EvenQ/@Exponent[minimalPolynomial[t],x,List]),
result=minimalPolynomial[t]/.x^r_:>x^(r/2);
(*DebugPrint["Testing minimal polynomial numerically."];
If[Chop[result/.x\[Rule]adaptiveN[GraphIndex[Translate[g,t]]]]=!=0,
Print["Calculating the minimal polynomial of the index seems to have gone wrong!"];
Print["x = ",GraphIndex[Translate[g,t]]];
Print["result = ",result/.x\[Rule]Global`q];
Abort[]
];*)
result,
DebugPrint["The minimal polynomial for the square root of the index wasn't even. Computing the minimal polynomial of the index directly..."];
MinimalPolynomial[GraphIndex[Translate[g,t]]][x]
]
,{t,0,maxVertices-GraphRank[g]}];
DebugPrint["Finished computing list of minimal polynomials."];
results
]


LeadingTerm[polynomial_,x_]:=
Coefficient[polynomial,x^(Exponent[polynomial,x])]


If[$VersionNumber<6.0,
Discriminant[polynomial_,x_]:=
Together[Resultant[polynomial, D[polynomial,x],x]/LeadingTerm[polynomial,x]]
]


(* Selects from the list of the first n primes the ones that do not divide the discriminant of polynomial *)
GoodPrimes[polynomial_,x_,n_]:=
Module[{Discriminant=Abs[Discriminant[polynomial,x]]}, Select[Table[Prime[k],{k,1,n}],Not[Mod[Discriminant,#]==0]&]];


(* Tests whether or not the given polynomial is the minimal polynomial of a cyclotomic integer.  Can return false positives. *)
PolyCyclotomicTest[polynomial_,primeBound_Integer:200, x_] :=
Module[{j,goodprimelist=GoodPrimes[polynomial,x,primeBound],AllTheSame,FactorPowersModp},
DebugPrint["Running PolyCyclotomicTest in a polynomial of degree ",Exponent[polynomial,x]];
AllTheSame[a_]:=Length[Union[a]]==1;
FactorPowersModp[poly_,p_Integer]:=
Exponent[#[[1]],x]&/@Rest[FactorList[poly,Modulus->p]];

If[Exponent[polynomial,x]==1,Return[True];,
For[j=1,j<=Length[goodprimelist],j++,
If[Not[AllTheSame[FactorPowersModp[polynomial,goodprimelist[[j]]]]],
Return[False];
];];];

(* If the first n primes can't rule it out, we'll return the (potentially false positive) True *)
True
];


(* Runs PolyCyclotomicTest on the list of minimal polynomials coming from the indices of graphs in a vine *)
CyclotomicTranslates[g_GradedBigraph]:=CyclotomicTranslates[g]=(If[DimensionOfGenerator[g]<2,Abort[]];CyclotomicTranslates[g,CyclotomicityBound[g]])
CyclotomicTranslates[g_GradedBigraph,maxVertices_Integer,primeBound_Integer:200]:=
Module[{graphList,minimalPolyList,goodPolyList,zipList,x},
graphList=Table[Translate[g,t],{t,0,maxVertices-GraphRank[g]}];
minimalPolyList=GetMinimalPolynomialList[g,maxVertices,x];
zipList=Table[{graphList[[t]],minimalPolyList[[t]]},{t,1,Length[graphList]}];
First/@Select[zipList,PolyCyclotomicTest[#[[2]],primeBound,x]&]
];


CyclotomicTranslates[G:{_BigraphWithDuals,_BigraphWithDuals}]:=Translate[G,#]&/@Cases[((GraphRank/@CyclotomicTranslates[G[[1,1]]])-GraphRank[G[[1,1]]]),n_/;EvenQ[n]]


(* Like PolynomialCyclotomicTest, but returns many primes all of which verify False results *)
MultiPrimePolynomialCyclotomicTest[polynomial_,primeBound_Integer:200, resultPrimeMax_Integer:10,x_] :=
Module[{j,goodprimelist=GoodPrimes[polynomial,x,primeBound],AllTheSame,FactorPowersModp,resultprimes={}},
AllTheSame[a_]:=Length[Union[a]]==1;
FactorPowersModp[poly_,p_Integer]:=
Exponent[#[[1]],x]&/@Rest[FactorList[poly,Modulus->p]];

If[Exponent[polynomial,x]==1,Return[{}];,
For[j=1,j<=Length[goodprimelist],j++,
If[Not[AllTheSame[FactorPowersModp[polynomial,goodprimelist[[j]]]]],
resultprimes=resultprimes~Join~{goodprimelist[[j]]};
If[Length[resultprimes]==resultPrimeMax,Return[resultprimes];];
];];];

(* If the first n primes can't rule it out, we'll return the (potentially false positive) True *)
resultprimes
];


(* Like CyclotomicTranslates, but attempts to find 2 primes that eliminate all of the graphs that fail the test *)
Clear[CyclotomicTranslatesWithWitnesses]
CyclotomicTranslatesWithWitnesses[g_GradedBigraph]:=CyclotomicTranslatesWithWitnesses[g]=CyclotomicTranslatesWithWitnesses[g,CyclotomicityBound[g]]
CyclotomicTranslatesWithWitnesses[g_GradedBigraph,maxVertices_Integer,primeBound_Integer:500,resultPrimeMax_Integer:50]:=
Module[{graphList,minimalPolyList,goodPolyList,zipList,resultlist,x,FrequentlyOccuring,graphlist,primelist,i,j,totalprimelist},
FrequentlyOccuring[list_]:=Union[Select[Flatten[list],Count[Flatten[list],#]>=Length[list]/2&]];
graphList=Table[Translate[g,t],{t,0,maxVertices-GraphRank[g]}];
minimalPolyList=GetMinimalPolynomialList[g,maxVertices,x];
zipList=Table[{graphList[[t]],minimalPolyList[[t]]},{t,1,Length[graphList]}];
resultlist={#[[1]],MultiPrimePolynomialCyclotomicTest[#[[2]],primeBound,resultPrimeMax,x]}&/@zipList;
{graphlist,totalprimelist,primelist}={First/@Select[resultlist,#[[2]]=={}&],#[[2]]&/@Select[resultlist,#[[2]]!={}&],FrequentlyOccuring[#[[2]]&/@Select[resultlist,#[[2]]!={}&]]};

If[Intersection@@totalprimelist!={},Return[{graphlist,{(Intersection@@totalprimelist)[[1]]}}]];

For[i=1,i<=Length[primelist],i++,
For[j=i+1,j<=Length[primelist],j++,
If[Select[totalprimelist,Intersection[primelist[[i;;i+1]],#]=={}&]=={},Return[{graphlist,primelist[[{i,j}]]}];];
];
];
Return[{graphlist,$Failed}];
];

CyclotomicTranslatesWithWitnesses[G:{_BigraphWithDuals,_BigraphWithDuals}]:={Translate[G,#]&/@Cases[((GraphRank/@CyclotomicTranslates[G[[1,1]]])-GraphRank[G[[1,1]]]),n_/;EvenQ[n]],CyclotomicTranslatesWithWitnesses[G[[1,1]]][[2]]}


End[];


EndPackage[];
