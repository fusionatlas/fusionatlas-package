(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["FusionAtlas`InductionMatrix`",{"FusionAtlas`","FusionAtlas`Bigraphs`","FusionAtlas`GraphPairs`","FusionAtlas`TensorSolver`","FusionAtlas`FormalCodegrees`"}];


InductionMatrices::usage="InductionMatrices[fr_FusionRules] computes the possible induction matrices to the centre for a fusion ring.";
AllDecompositions::usage="AllDecompositions[m] for m a symmetric non-negative integer matrix, gives all matrices a so a.Transpose[a] == m";


Begin["`Private`"];


Clear[InductionMatrices]
InductionMatrices[fr_FusionRules]:=InductionMatrices[fr]=Module[{n,dimensionData},
dimensionData=DimensionData[fr];
n=If[IntegerQ[dimensionData[[1]]],1,identify\[Zeta][dimensionData[[1,1]]]];
Select[
Cases[AlgebraicDecompositions[AnnularHoms[fr],dimensionData],m_/;Count[Transpose[m],UnitVector[Length[m],1]]>=1],
CheckGaloisAction[n,dimensionData]
]
]


InductionMatrices[g_GradedBigraph]:={#,InductionMatrices[#]}&/@(EvenPartFusionRules/@FindFusionRules[g])


CheckGaloisAction[n_,dimensionData_][inductionMatrix_]:=Module[{\[ScriptCapitalD],dimensions},
\[ScriptCapitalD]=dimensionData[[1]];
dimensions=Sort[Transpose[inductionMatrix].(dimensionData[[2,1]])];
And@@Table[Sort[abs[GaloisAction[n][l][#/\[ScriptCapitalD]]\[ScriptCapitalD]]&/@dimensions]==dimensions,{l,GaloisGroup[n]}]
]


Clear[\[Zeta]]
\[Zeta][n_]:=\[Zeta][n]=With[{p=Evaluate[Cyclotomic[n,#]]&},With[{d=Module[{m},Exponent[p[m],m]]},
AlgebraicNumber[Root[p,d],{0,1}~Join~Table[0,{d-2}]]]]


Clear[identify\[Zeta]]
identify\[Zeta][z_]:=identify\[Zeta][z]=Module[{n=1},While[z=!=\[Zeta][n]\[And](n<=2\[Or]z=!=\[Zeta][n][[1]]),n++];n]


ToCyclotomicField[X_List]:=ToCyclotomicField[X,1][[1]]
ToCyclotomicField[X_List?MatrixQ]:=Partition[ToCyclotomicField[Flatten[X]],Length[X[[1]]]]
ToCyclotomicField[{},n_]:={{},n}
ToCyclotomicField[{x_,z___},n_]:=Module[{tnf,k=1,zt,p},
Quiet[
tnf=cachedToNumberField[x,\[Zeta][n]];
While[MatchQ[tnf,_ToNumberField],
k++;
n0=k n;
tnf=cachedToNumberField[x,\[Zeta][k n]]
],
ToNumberField::nnfel];
{zt,p}=ToCyclotomicField[{z},k n];
{{AlgebraicNumberPolynomial[tnf,\[Zeta][p]^(p/(k n))]}~Join~zt,p}
]


AnnularHoms[f_FusionRules]:=Module[{m,d,n,objects},
m[i_,j_,k_]:={i,j,k}/.f[[-1]];
n[i_,j_]:=Length[m[i,j,j]];
d[i_,i_]:=Ordering[Position[#,1]&/@m[i,i,i][[All,All,1]]];
d[i_,j_]:=Range[n[0,1]];
objects=Flatten[Table[{i,k},{i,0,Max[Flatten[f[[-1,All,1]]]]},{k,1,n[i,i]}],1];
Table[Sum[m[q[[1]],p[[1]],p[[1]]][[s,p[[2]],t]]m[p[[1]],q[[1]],q[[1]]][[d[p[[1]],q[[1]]][[s]],d[q[[1]],q[[1]]][[q[[2]]]],d[p[[1]],q[[1]]][[t]]]],{s,1,n[p[[1]],q[[1]]]},{t,1,n[p[[1]],q[[1]]]}],{p,objects},{q,objects}]
]


AnnularHoms[{G1_BigraphWithDuals,G2_BigraphWithDuals}]:=AnnularHoms/@FindFusionRules[G1,G2]


DimensionData[G:{_BigraphWithDuals,_BigraphWithDuals},\[Lambda]0_:0]:=Module[{\[Lambda],\[ScriptCapitalD],dims,dimsForFormalCodegrees},
\[Lambda]=ToCyclotomicField[If[\[Lambda]0==0,RootReduce[GlobalEvenDimension[G[[1,1]]]],\[Lambda]0]];
\[ScriptCapitalD]=ToNumberField[GlobalEvenDimension[G[[1,1]]],\[Lambda]];
dims={ToNumberField[Flatten[DimensionsByDepth[G[[1]]][[1;;;;2]]],\[Lambda]]~Join~ZeroVector[GraphEvenRank[G[[2]]]],
ZeroVector[GraphEvenRank[G[[1]]]]~Join~ToNumberField[Flatten[DimensionsByDepth[G[[2]]][[1;;;;2]]],\[Lambda]]};
{\[ScriptCapitalD],dims}]


DimensionData[fr_FusionRules]:=Module[{\[Lambda],dims,codegrees,\[ScriptCapitalD]},
dims=ToCyclotomicField[ToNumberField[FPDimensions[fr]]];
If[MemberQ[dims,_AlgebraicNumber],
\[Lambda]=Cases[dims,_AlgebraicNumber][[1,1]];
codegrees=ToNumberField[FormalCodegrees[fr],\[Lambda]],
codegrees=FormalCodegrees[fr]
];
dims=dims/dims[[1]];
\[ScriptCapitalD]=Sum[d^2,{d,dims}];
{\[ScriptCapitalD],{dims},\[ScriptCapitalD]/codegrees}
]


dNumberQ=FusionAtlas`dTest`Private`dNumberQ;


Clear[columnCondition]
columnCondition[{\[ScriptCapitalD]_,dims_,dimsForFormalCodegrees_}][v_]:=columnCondition[{\[ScriptCapitalD],dims,dimsForFormalCodegrees}][v]=With[{d=dims.v},
numberOfColumnsToCheck--;
(True\[Or]v[[1]]!=1\[Or]Length[Complement[d,dimsForFormalCodegrees]]==0)\[And]
dimensionCondition[\[ScriptCapitalD],d]
]
Clear[dimensionCondition]
dimensionCondition[\[ScriptCapitalD]_,d_]:=dimensionCondition[\[ScriptCapitalD],d]=(And@@(Chop[N[#]]>0&/@d))\[And](And@@(AlgebraicIntegerQ/@(\[ScriptCapitalD]/d)))\[And](And@@(dNumberQ/@d))


DowndateCholeskyDecomposition[L0_,x0_]:=Module[{L=L0,x=x0,p=Length[x0],d,r,c,s},
Do[
d=L[[k,k]]^2-x[[k]]^2;
If[d<0,Return[L=None]];
r=Sqrt[d];
c=r/L[[k,k]];
s=x[[k]]/L[[k,k]];
(*Print[{k,L,x,r}];*)
L[[k,k]]=r;
L[[k,k+1;;]]=(L[[k,k+1;;]]-s x[[k+1;;]])/c;
x[[k+1;;]]=c x[[k+1;;]]-s L[[k,k+1;;]];
,{k,1,p}];
(*Print[L];*)
L
]


GaloisGroup[n_]:=GaloisGroup[n]=Cases[Table[i,{i,1,n-1}],i_/;GCD[i,n]==1]


cachedToNumberField[a_,b_]:=cachedToNumberField[a,b]=ToNumberField[a,b]


GaloisConjugates[a:AlgebraicNumber[x_,c_]]:=With[{n=identify\[Zeta][x]},
Union[Table[AlgebraicNumberPolynomial[a,\[Zeta][n]^l],{l,GaloisGroup[n]}]]
]
GaloisConjugates[x:(_Integer|_Rational)]:={x}


cachedRootReduce[x_]:=cachedRootReduce[x]=RootReduce[x]
abs[x_]:=Sign[cachedRootReduce[x]]x


GaloisAction[n_][l_][a:AlgebraicNumber[r_,x_]]/;r==\[Zeta][n][[1]]:=GaloisAction[n][l][a]=AlgebraicNumberPolynomial[a,\[Zeta][n]^l]
GaloisAction[n_][l_][a:(_Integer|_Rational)]:=a


Clear[AllowedColumns]
AllowedColumns[m_,dimensionData_]:=Module[{bounds,allColumns,\[ScriptCapitalD],allowedColumns,columnDimensions},
bounds=Table[Floor[Sqrt[m[[i,i]]]],{i,1,Length[m]}];
numberOfColumnsToCheck=Times@@(#+1&/@bounds)-1;
allColumns=DeleteCases[Flatten[Table[Table[a[i],{i,1,Length[m]}],Evaluate[Sequence@@Table[{a[i],Range[0,bounds[[i]]]},{i,1,Length[m]}]]],Length[m]-1],{0..}];
numberOfColumnsToCheck=Length[allColumns];
allowedColumns=Sort[Cases[allColumns,c_/;columnCondition[dimensionData][c]]];
(* Now check that for every column c, there exist columns giving all the Galois conjugates of dim(c)/\[ScriptCapitalD] *)
\[ScriptCapitalD]=dimensionData[[1]];
columnDimensions=allowedColumns.(dimensionData[[2,1]]);
Cases[allowedColumns,c_/;Length[Complement[abs[GaloisConjugates[(c.(dimensionData[[2,1]]))/\[ScriptCapitalD]]\[ScriptCapitalD]],columnDimensions]]==0]
]


AllDecompositions[m_]:=Module[{bounds,columns},
bounds=Table[Floor[Sqrt[m[[i,i]]]],{i,1,Length[m]}];
columns=DeleteCases[Flatten[Table[Table[a[i],{i,1,Length[m]}],Evaluate[Sequence@@Table[{a[i],Range[0,bounds[[i]]]},{i,1,Length[m]}]]],Length[m]-1],{0..}];
Transpose/@AlgebraicDecompositionsImplementation[m,N[CholeskyDecomposition[m+0.001IdentityMatrix[Length[m]]]],{},columns]
]


Clear[AlgebraicDecompositions]
AlgebraicDecompositions[m_,dimensionData:{_,_,_}]/;MatrixRank[m]==Length[m]:=AlgebraicDecompositions[m,dimensionData]=Transpose/@AlgebraicDecompositions[m,N[CholeskyDecomposition[m+0.001IdentityMatrix[Length[m]]]],dimensionData,{}]
AlgebraicDecompositions[m_,{\[ScriptCapitalD]_,dims_,dimsForFormalCodegrees_}]/;MatrixRank[m]<Length[m]:=Module[{mr,dr,i},
{mr,dr,i}=RankReduction[m,dims];
Transpose[i].#&/@AlgebraicDecompositions[mr,{\[ScriptCapitalD],dr,dimsForFormalCodegrees}]
]
AlgebraicDecompositions[m_,cholesky_,{\[ScriptCapitalD]_,dims_,dimsForFormalCodegrees_},{}]:=Module[{bounds,allColumns,allowedColumns},
allowedColumns=AllowedColumns[m,{\[ScriptCapitalD],dims,dimsForFormalCodegrees}];
AlgebraicDecompositionsImplementation[m,cholesky,{},allowedColumns]
]
AlgebraicDecompositionsImplementation[m_,None,columns_,allowedColumns_]:={}
AlgebraicDecompositionsImplementation[m_,cholesky_,columns_,allowedColumns_]/;Union[Flatten[m]]==={0}:=((*Print[{columns}];*){columns})
AlgebraicDecompositionsImplementation[m_,cholesky_,columns_,allowedColumns_]:=Module[{t,i,bounds,firstNonZeroRow,nextColumns,nextAllowedColumns},
latestColumn=columns;
(*Print["decomposing: " ,m ," with columns: ",columns];*)
bounds=Table[Floor[Sqrt[m[[i,i]]]],{i,1,Length[m]}];
firstNonZeroRow=Position[m,x_Integer/;x>0][[1,1]];
If[Length[columns]>0,
i=Position[allowedColumns,columns[[-1]]][[1,1]];
nextAllowedColumns=Take[allowedColumns,i],
nextAllowedColumns=allowedColumns
];
nextAllowedColumns=Cases[nextAllowedColumns,c_/;(And@@Table[c[[i]]<=bounds[[i]],{i,1,Length[m]}])];
nextColumns=Cases[nextAllowedColumns,c_/;(c[[firstNonZeroRow]]!=0)];
numberOfColumnsToCheck=Length[nextColumns];
(*Print[Length[allowedNextColumns]];*)
Join@@(AlgebraicDecompositionsImplementation[m-Outer[Times,#,#],DowndateCholeskyDecomposition[cholesky,#],columns~Join~{#},nextAllowedColumns]&/@nextColumns)
]



identityColumn[FusionRules[_,{{0,0,0}->{m_,___}}]]:=UnitVector[Length[m],1]


FindSpanningSet[m_?MatrixQ]:=FindSpanningSetI[0,{},{},m]
FindSpanningSet[{}]:={}
FindSpanningSetI[considered_,basis_,rowReduced_,{}]:=basis
FindSpanningSetI[considered_,basis_,rowReduced_,remaining_]:=Module[{newRR},
newRR=DeleteCases[RowReduce[rowReduced~Join~{remaining[[1]]}],{0..}];
If[Length[newRR]==Length[rowReduced],
FindSpanningSetI[considered+1,basis,rowReduced,Rest[remaining]],
FindSpanningSetI[considered+1,basis~Join~{considered+1},newRR,Rest[remaining]]
]
]


RankReduction[m_,dims_]:=Module[{p,o,mr,m2,i},
o=Ordering[Table[m[[i,i]],{i,1,Length[m]}]];
p=FindSpanningSet[m[[o,o]]];
mr=m[[o,o]][[p,p]];
p=p~Join~Complement[Range[Length[m]],p];
oi=InversePermutation[o];
pi=InversePermutation[p];
m2=m[[o,o]][[p,p]];
i=RowReduce[NullSpace[NullSpace[m2]]][[All,pi]][[All,oi]];
{mr,dims.Transpose[i],i}
]


End[];


EndPackage[];
