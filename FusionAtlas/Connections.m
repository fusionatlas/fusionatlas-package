(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["FusionAtlas`Connections`",{"FusionAtlas`","FusionAtlas`Bigraphs`","FusionAtlas`GraphPairs`","FusionAtlas`Debugging`","FusionAtlas`RelativeDimensions`"}];


ClearConnection;ConnectionEquations;SimplifyConnectionEquations;BranchMatrix;UUt;ConnectionNormEquations;ConnectionPhaseEquations;SolveConnectionNormEquations;SolveConnectionNormEquationsForExtraDimensions;SolveConnectionPhaseEquations;ConnectionNormConditions;ReducedConnectionNormConditions;ConnectionTriangleInequalities;ConnectionPolygonInequalities;IndexRangeFromConnectionNorms;IndexRangeFromTriangleInequalities;ConnectionTrianglesNormsAndArgs;complicatedOnes;newComplicatedOne;PhaseSolver;LawOfCosinesAlternatives;norm;arg;


Begin["`Private`"];


K=System`K;
q=Global`q;


simplifyKCoefficient[x_]:=simplifyKCoefficient[x]=(If[NumericQ[x],cachedRootReduce[x],Together[x]])


ClearConnection[g_]:=Module[{},
DownValues[K]=With[{gs=GraphToString/@g},DeleteCases[DownValues[K]/.HoldPattern->Hold,Hold[K[_,_,gs]]:>_]/.Hold->HoldPattern];
DownValues[ConnectionEquations]=DeleteCases[DownValues[ConnectionEquations],c_/;!FreeQ[c,g]];
DownValues[ConnectionNormEquations]=DeleteCases[DownValues[ConnectionNormEquations],c_/;!FreeQ[c,g]];
]


K[loop_List,g_]:=Power[K["r2",loop,g],1/2]K["\[Theta]",loop,g];
Unprotect[Conjugate];
Conjugate[Sqrt[K["r2",x_,g_]]]:=Sqrt[K["r2",x,g]];
Conjugate[Sqrt[x_]]:=Sqrt[x]
Protect[Conjugate];
K/:Conjugate[K["\[Theta]",x_,g_]]:=Power[K["\[Theta]",x,g],-1];


Clear[norm]
norm[x_Times]:=norm/@x;
norm[x_^k_Integer]:=norm[x]^k;
norm[x_?NumericQ]:=RootReduce[Abs[RootReduce[x]]];
norm[k:K["r2",_,_]]:=k;
norm[k:K["\[Theta]",_,_]]:=1;
norm[x:Sqrt[K["r2",_,_]]]:=x;
norm[Sqrt[x_]]:=Sqrt[x]


Clear[arg]
arg[x_Times]:=arg/@x;
arg[x_^k_Integer]:=arg[x]^k
arg[x_?NumericQ/;Im[x]==0]:=Sign[x];
arg[x_?NumericQ]:=RootReduce[x/Abs[x]];
arg[Sqrt[K["r2",_,_]]]:=1;
arg[k:K["\[Theta]",_,_]]:=k;


ConnectionEquations[G:{_String,_String},modifiers__]:=ConnectionEquations[GraphFromString/@G,modifiers]


ConnectionEquations[G:{_BigraphWithDuals,_BigraphWithDuals},translations:(True|False):False,extensions:(True|False):False]:=ConnectionEquations[G,translations,extensions]=Module[{gs,dimensionFunction,dim,loops,entries,renormalization,vertexPairs,shading,nextShading, unitaryBlock,unitarityEquations,unitarity},
gs=GraphToString/@G;
dimensionFunction=If[translations\[Or]extensions,Simplify[RelativeDimensionsByDepth[Sequence@@G,If[extensions,1,0]][d,If[translations,Log[a]/Log[q],0],q]],RootReduce[DimensionsByDepth[G]]];
dim[Vertex[i_,j_,k_,l_]]:=dimensionFunction[[i+1,k+1,l]];
loops=GraphLoops[G,{{0,0},{0,1},{1,1},{1,0},{0,0}}];
renormalization=Flatten[{K["r2",#,gs]-cachedRootReduce[Together[(dim[#[[3]]]dim[#[[7]]])/(dim[#[[1]]]dim[#[[5]]])]]K["r2",RotateLeft[#,2],gs],K["\[Theta]",#,gs]-K["\[Theta]",RotateLeft[#,2],gs]}&/@loops];
entries=(K[#,gs]&/@loops)~Join~(K[RotateLeft[#,2],gs]&/@loops);
vertexPairs=Flatten[Outer[List,GraphVertices[G,{0,0}],GraphVertices[G,{1,1}]]~Join~Outer[List,GraphVertices[G,{0,1}],GraphVertices[G,{1,0}]],1];
vertexPairs=Cases[vertexPairs,{Vertex[_,_,d1_,_],Vertex[_,_,d2_,_]}/;Abs[d1-d2]<=2];
If[translations,
vertexPairs=DeleteCases[vertexPairs,{Vertex[_,_,0,_],Vertex[_,_,0,_]}];
];
If[extensions,
vertexPairs=DeleteCases[vertexPairs,{Vertex[_,_,GraphDepth[G[[1]]],_],Vertex[_,_,GraphDepth[G[[1]]],_]}];
];
Global`vertexPairs0=vertexPairs;
Global`unitaryBlock0=unitaryBlock;
shading[Vertex[i_,j_,_,_]]:={i,j};
nextShading[{0,0}]={0,1};
nextShading[{0,1}]={1,1};
nextShading[{1,1}]={1,0};
nextShading[{1,0}]={0,0};
unitaryBlock[vertexPair_]:=Module[{p1,p2},
p1=GraphPathsBetween[G,Sequence@@vertexPair,{shading[vertexPair[[1]]],nextShading[shading[vertexPair[[1]]]],shading[vertexPair[[2]]]}];
p2=GraphPathsBetween[G,Sequence@@Reverse[vertexPair],{shading[vertexPair[[2]]],nextShading[shading[vertexPair[[2]]]],shading[vertexPair[[1]]]}];
Outer[K[Most[ConcatenatePaths[#1,#2]],gs]&,p1,p2,1]
];
unitarityEquations[vertexPair_]:=With[{U=unitaryBlock[vertexPair]},
Switch[Length[U],
0,{},
1,{Power[norm[U[[1,1]]],2]-1},
2,{Power[norm[U[[1,1]]],2]+Power[norm[U[[1,2]]],2]-1,Power[norm[U[[2,1]]],2]-Power[norm[U[[1,2]]],2],Power[norm[U[[1,1]]],2]-Power[norm[U[[2,2]]],2],arg[U[[1,1]]]Power[arg[U[[1,2]]],-1]+arg[U[[2,1]]]Power[arg[U[[2,2]]],-1]},
_,Flatten[U.Conjugate[Transpose[U]]-IdentityMatrix[Length[U]]]~Join~Flatten[Conjugate[Transpose[U]].U-IdentityMatrix[Length[U]]]]];
unitarity=Flatten[unitarityEquations/@vertexPairs];
DeleteCases[Collect[renormalization~Join~unitarity,_K,simplifyKCoefficient],0]
]


SimplifyConnectionEquations[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{},
ConnectionEquations[G,translate,extend]=DeleteCases[Collect[Cases[ConnectionEquations[G,translate,extend],c_/;FreeQ[c,Power[Except[_?NumericQ],1/2]]],_K,simplifyKCoefficient],0]~Join~(Cases[ConnectionEquations[G,translate,extend],c_/;!FreeQ[c,Power[Except[_?NumericQ],1/2]]]/.Power[x_,1/2]:>Power[simplifyKCoefficient[x],1/2])
]


BranchMatrix[G_]:=Module[{b=DepthOfBranchPoint[G[[1]]],gs,vertexPair,shading,nextShading,unitaryBlock,argSolution},
gs=GraphToString/@G;
vertexPair={Vertex[0,If[EvenQ[b],0,1],b,1],Vertex[1,If[EvenQ[b],1,0],b,1]};
shading[Vertex[i_,j_,_,_]]:={i,j};
nextShading[{0,0}]={0,1};
nextShading[{0,1}]={1,1};
nextShading[{1,1}]={1,0};
nextShading[{1,0}]={0,0};
unitaryBlock=Module[{p1,p2},
p1=GraphPathsBetween[G,Sequence@@vertexPair,{shading[vertexPair[[1]]],nextShading[shading[vertexPair[[1]]]],shading[vertexPair[[2]]]}];
p2=GraphPathsBetween[G,Sequence@@Reverse[vertexPair],{shading[vertexPair[[2]]],nextShading[shading[vertexPair[[2]]]],shading[vertexPair[[1]]]}];
Outer[K[Most[ConcatenatePaths[#1,#2]],gs]&,p1,p2,1]
];
Collect[unitaryBlock,_K,simplifyKCoefficient]
]


UUt[G_,rules:{___Rule}:{}]:=Module[{b=DepthOfBranchPoint[G[[1]]],unitaryBlock,argSolution},
unitaryBlock=BranchMatrix[G]/.rules;
argSolution=Solve[((#==1&/@(arg/@Rest[unitaryBlock[[1]]]~Join~Rest[unitaryBlock[[All,1]]]))~Join~{arg[unitaryBlock[[1,1]]]==(-1)^(b+1)})/.arg[Sqrt[_]]:>1][[1]];
Collect[unitaryBlock.Transpose[unitaryBlock]/.argSolution,_K,simplifyKCoefficient]
]


Clear[ConnectionNormEquations]


ConnectionNormEquations[G_,translate:(True|False):False,extend:(True|False):False]:=Cases[ConnectionEquations[G,translate,extend],c_/;FreeQ[c,"\[Theta]"]]


ConnectionPhaseEquations[G_,translate:(True|False):False,extend:(True|False):False]:=Cases[ConnectionEquations[G,translate,extend],c_/;FreeQ[c,"r2"]]


trivialInequality[x_]/;FreeQ[x,d]:=Reduce[ForAll[a,a>=1,ForAll[q,q>1,x]]]===True
trivialInequality[_]:=False


LinearComboQ[e_,p_]:=MatchQ[e,p]\[Or](MatchQ[e,_Plus]\[And](MatchQ[#,p|(_?(FreeQ[#,p]&))|((_?(FreeQ[#,p]&)* p))]&/@(And@@e)))


SolveConnectionNormEquations[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{c,ne,targets,sol,Ks,gs},
gs=GraphToString/@G;
Ks[f_]:=Union[Cases[f,_K,\[Infinity]]];
ne=ConnectionNormEquations[G,translate,extend];
c=0;
While[SimplifyConnectionEquations[G,translate,extend];ne=DeleteCases[Union[Collect[ne,_K,simplifyKCoefficient]],0];ConnectionNormEquations[G,translate,extend]=ne;
++c<\[Infinity]\[And]Length[targets=Cases[ne,(*S:HoldPattern[Plus[((_K)|(_?(FreeQ[#,_K]&))|((_?(FreeQ[#,_K]&)* _K)))...]]*)S_/;LinearComboQ[S,_K]/;!FreeQ[S,K],1,1]]>0,
sol=Solve[targets==0,Ks[targets][[1]]];
If[Length[sol]!=1,Print["Didn't have a unique solution:"];Print[sol];Abort[]];
sol[[1]]/.(x_->y_):>(x=Collect[y,_K,simplifyKCoefficient]);
DownValues[K]=DownValues[K]/.(x_:>y_)/;Length[x[[1]]]==3\[And]x[[1,3]]==gs:>(x:>Evaluate[y])
];

]


SolveConnectionNormEquationsForExtraDimensions[G_,False,True]:=Module[{target,sol},
target=Cases[ConnectionNormConditions[G,False,True],x_==0/;MatchQ[Expand[x/.q->N[\[Pi]]],a_?NumericQ+b_?NumericQ d[_][_,_]],1,1];
sol=Solve[target,Union[Cases[target,d[_][_,_],\[Infinity]]]][[1]];
sol/.(x_->y_):>(x=y);
ConnectionEquations[G,translate,extend]=DeleteCases[Collect[ConnectionEquations[G,translate,extend],_K,simplifyKCoefficient],0];
]


Clear[SolveConnectionPhaseEquations]


SolveConnectionPhaseEquations[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{c,ne,targets,Ks},
Ks[f_]:=Union[Cases[f,_K,\[Infinity]]];
ne=ConnectionPhaseEquations[G,translate,extend];
c=0;
While[SimplifyConnectionEquations[G,translate,extend];ne=DeleteCases[Union[Collect[ne,_K,RootReduce]],0];
++c<\[Infinity]\[And]Length[targets=Cases[ne,HoldPattern[(_K+_?(FreeQ[#,_K]&)* _K)|(aa_K/bb_K+cc_K/dd_K)|HoldPattern[(r:Times[((_?NumericQ)|(_K)|(Power[_K,-1]))...])+(s:Times[((_?NumericQ)|(_K)|(Power[_K,-1]))...])/;RootReduce[norm[r]-norm[s]]==0]|(-aa_K+HoldPattern[Times[(_K|(_K)^-1)...]])|(-aa_K+Times[-1,(_K|(_K)^-1)...])],1,1]]>0,
sol=Solve[targets==0,Ks[targets][[1]]];
sol/.(x_->y_):>(x=y);
];
]


Clear[ConnectionNormConditions]


aqConditions[G_,translate_,extend_]:={If[translate\[Or]extend,q>=qFromd[DimensionOfGenerator[G]],q==qFromd[DimensionOfGenerator[G]]],If[translate,a>=1,a==1]}


ConnectionNormConditions[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{ne,gs},
gs=GraphToString/@G;
ne=ConnectionNormEquations[G,translate,extend];
aqConditions[G,translate,extend]~Join~DeleteCases[(Collect[Numerator[#],_K]==0&/@Together[ne])~Join~(#>=0&/@Union[Collect[K["r2",#,gs]&/@GraphLoops[G,{{0,0},{0,1},{1,1},{1,0},{0,0}}],_K,simplifyKCoefficient]]),True]
]


ReducedConnectionNormConditions[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{conditions=ConnectionNormConditions[G,translate,extend]},
(#==0&/@GroebnerBasis[Cases[conditions,(a_==b_/;FreeQ[{a,b},d]):>(a-b)],{a,q}])~Join~{Reduce[Cases[conditions,(a_==b_/;!FreeQ[{a,b},d])]~Join~aqConditions[G,translate,extend],Union[Cases[conditions,d[_][_,_],\[Infinity]]]]}~Join~DeleteCases[conditions,(a_==b_)]
]


Clear[ConnectionTriangleInequalities]


ConnectionTriangles[G_,translate:(True|False):False,extend:(True|False):False]:=List@@#&/@Cases[Expand[ConnectionEquations[G,translate,extend]],c_/;Length[c]==3]


ConnectionTriangleInequalities[G_,translate:(True|False):False,extend:(True|False):False]:=ConnectionTriangleInequalities[G,translate,extend]=Module[{tri,qtri0,qtri,surelyPositive,inequalities},
tri[{a_,b_,c_}]:=PowerExpand[{(norm[a]+norm[b])^2-norm[c]^2,(norm[a]+norm[c])^2-norm[b]^2,(norm[b]+norm[c])^2-norm[a]^2}];
qtri0[{a_,b_,c_}]:=Times@@(#[[1]]^#[[2]]&/@Cases[FactorList[Together[PowerExpand[4norm[a]^2 norm[b]^2-(norm[a]^2+norm[b]^2-norm[c]^2)^2]]],{_,_?OddQ}]);
qtri[{a_,b_,c_}]:={qtri0[{a,b,c}],qtri0[{b,c,a}],qtri0[{c,a,b}]};
surelyPositive[x_]:=surelyPositive[x]=Reduce[ForAll[q,q>=1,ForAll[a,a>=1,x>=0]]]===True;
inequalities=Union[#>=0&/@Cases[Flatten[(qtri/@ConnectionTriangles[G,translate,extend])/.norm[Sqrt[x_]](*/;surelyPositive[x]*):>Sqrt[x]],c_/;FreeQ[c,norm]]];
inequalities
]


ConnectionPolygonInequalities[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{diffs,inequalities},
diffs[x_List]:=Table[(-norm[x[[1]]]+Plus@@(norm/@x))^2-norm[x[[i]]]^2,{i,1,Length[x]}];
inequalities=Union[#>=0&/@Cases[Flatten[(diffs/@(List@@#&/@DeleteCases[Expand[ConnectionEquations[G,translate,extend]],0]))/.norm[Sqrt[x_]]:>Sqrt[x]],c_/;FreeQ[c,norm]]];
inequalities
]


IndexRangeFromConnectionNorms[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{x,y},
x=ConnectionNormConditions[G,translate,extend];
If[!FreeQ[x,d],Return[$Failed]];
y=Reduce[x];
RootReduce[{Minimize[{(q+q^-1)^2,y},{a,q}][[1]],Maximize[{(q+q^-1)^2,y},{a,q}][[1]]}]
]


IndexRangeFromTriangleInequalities[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{x,y},
x=ConnectionTriangleInequalities[G,translate,extend];
If[!FreeQ[x,d],Return[$Failed]];
y=Reduce[x];
RootReduce[{Minimize[{(q+q^-1)^2,y},{a,q}][[1]],Maximize[{(q+q^-1)^2,y},{a,q}][[1]]}]
]


ProgressiveReduce[x_List]:=Fold[(Reduce[{##}])&,True,x]


ConnectionTrianglesNormsAndArgs[G_,translate:(True|False):False,extend:(True|False):False]:=Module[{triangleToNormsAndArgs},
triangleToNormsAndArgs[t_]:={norm/@t,arg/@t}/.{norm[Sqrt[x_]]:>Sqrt[Collect[x,_K,RootReduce]],arg[Sqrt[_]]:>1};
triangleToNormsAndArgs/@ConnectionTriangles[G,translate,extend]
]


LawOfCosines[{{a_,b_,c_},{\[Alpha]_,\[Beta]_,\[Gamma]_}}]:=
Module[{ExpArcCos},
ExpArcCos[x_?NumericQ]:=RootReduce[x+I Sqrt[1-x^2]];
ExpArcCos[x_]:=x+I Sqrt[1-x^2];
Expand[{{-\[Alpha] \[Beta]^-1,ExpArcCos[(c^2-a^2-b^2)/(-2a b)]},
{-\[Beta] \[Gamma]^-1, ExpArcCos[(a^2-b^2-c^2)/(-2b c)]},
{-\[Gamma] \[Alpha]^-1,ExpArcCos[(b^2-c^2-a^2)/(-2c a)]}}]
]


LawOfCosinesAlternatives[{{a_,b_,c_},{\[Alpha]_,\[Beta]_,\[Gamma]_}}]:=Module[{q1,q2,q3,q4,q5,q6},
{{q1,q2},{q3,q4},{q5,q6}}=LawOfCosines[{{a,b,c},{\[Alpha],\[Beta],\[Gamma]}}];
((q1 q2^-1==1)\[And](q3 q4^-1==1)\[And](q5 q6^-1==1))\[Or]((q1 q2==1)\[And](q3 q4==1)\[And](q5 q6==1))
]


complicatedOnes={};


newComplicatedOne[x_]:=(complicatedOnes=Union[Append[complicatedOnes,x]];)


Clear[reduceRules,addNewRules]


reduceRules[rules:{___Rule}]:=rules//.{(x_->y_):>(x->(cachedRootReduce[y//.rules]))}


addNewRules[oldRules:{___Rule},newRules:{___Rule}]:=Module[{reducedRules},
reducedRules=reduceRules[newRules];
(oldRules/.{(x_->y_):>(x->(cachedRootReduce[y/.reducedRules]))})~Join~reducedRules
]


(* PhaseSolver returns a list of alternative lists of rules. The first argument is a list of rules. *)


Clear[PhaseSolver]


fastAndLooseRootReduce[x_?NumericQ]:=fastAndLooseRootReduce[x]=Module[{approximation,precision=100},
DebugPrint["starting fastAndLooseRootReduce: ",x];
Off[N::meprec];
While[approximation=RootApproximant[N[x,precision]];
(Chop[Abs[N[x-approximation,2*precision]],10^(-2*precision+1)]=!=0),
DebugPrint["increasing precision to ",precision*2];precision*=2];
On[N::meprec];
DebugPrint["finished"];
approximation
]


cachedRootReduce[x_ k_K]:=cachedRootReduce[x]k
cachedRootReduce[x_ Power[k_K,-1]]:=cachedRootReduce[x]Power[k,-1]
cachedRootReduce[k_K]:=k
cachedRootReduce[Power[k_K,n_]]:=Power[k,n]


cachedRootReduce[x_]:=Module[{},
DebugPrint["starting cachedRootReduce: ",x];
cachedRootReduce[x]=RootReduce[x];
DebugPrint["finished"];
cachedRootReduce[x]
]
cachedRootReduce[x_]:=If[NumericQ[x],fastAndLooseRootReduce[x],cachedRootReduce[x]=RootReduce[x]]
cachedRootReduce[-x_]:=cachedRootReduce[-x]=RootReduce[-cachedRootReduce[x]]
cachedRootReduce[Power[x_,k_]]:=cachedRootReduce[Power[x,k]]=RootReduce[Power[x,k]]
cachedRootReduce[x_Integer]:=x


PhaseSolver[newRules:{___Rule}/;Length[newRules]>0,rules:{___Rule},X_]:=PhaseSolver[{},addNewRules[rules,newRules],(X/.newRules)/.x_?NumericQ:>cachedRootReduce[x]]


phaseSolverLevel=0;


PhaseSolver[{},rules:{___Rule},And[X_,Y__]]:=Module[{d=Length[{X,Y}],f,r},
phaseSolverLevel++;
DebugPrint[phaseSolverLevel,"PhaseSolver looking at first equation in And (depth ",d,")"];
f=PhaseSolver[{},rules,X];
DebugPrint[phaseSolverLevel,"PhaseSolver recursing into And... (depth ",d,")"];
r=Flatten[PhaseSolver[#,{},And[Y]]&/@f,1];
DebugPrint[phaseSolverLevel,"PhaseSolver finished recursing into And (depth ",d,")"];
phaseSolverLevel--;
r
]


PhaseSolver[{},rules:{___Rule},X_Or]:=Module[{r},
phaseSolverLevel++;
DebugPrint[phaseSolverLevel," PhaseSolver mapping over Or..."];
r=Union[Flatten[PhaseSolver[{},rules,#]&/@List@@(X),1]];
phaseSolverLevel--;
r
]


PhaseSolver[{},rules:{___Rule},True]:={rules} (* one alternative, no additional rules *)
PhaseSolver[{},{___Rule},False]:={} (* no alternatives *)
PhaseSolver[{},rules:{___Rule},(x_K|x_K^-1)==1]:=Module[{},
DebugPrint["rules so far: ",First/@rules];
DebugPrint["solving: ",Short[x]==1];
{addNewRules[rules,{x->1}]}
]
PhaseSolver[{},rules:{___Rule},x_==1/;NumericQ[x]]:=Module[{},
DebugPrint["PhaseSolver dealing with a numeric equation"];
If[NumericQ[x],
Switch[RootReduce[x]==1,
True,{rules},
False,{},
_,Print["PhaseSolver couldn't deal with a numeric equation: ",x==1];lastPhaseSolverProblem=x;Abort[]]
]
]
(*PhaseSolver[{},rules:{___Rule},Power[x_,-1]\[Equal]1]:=PhaseSolver[{},rules,x]*)
PhaseSolver[{},rules:{___Rule},x_*(k:K["\[Theta]",_,_])==1]:=
Module[{},
DebugPrint["PhaseSolver solving: ",x k ==1];
{addNewRules[rules,{k->Power[x,-1]}]}
]
PhaseSolver[{},rules:{___Rule},x_*Power[k:K["\[Theta]",_,_],-1]==1]:=Module[{},
DebugPrint["PhaseSolver solving: ",x Power[k,-1] ==1];
{addNewRules[rules,{k->x}]}
]
PhaseSolver[{},rules:{___Rule},x_*Power[k:K["\[Theta]",_,_],2]==1]:=Module[{},
DebugPrint["PhaseSolver solving: ",x Power[k,2] ==1];
{addNewRules[rules,{k->1/safeSqrt[x]}],addNewRules[rules,{k->-1/safeSqrt[x]}]}
]
PhaseSolver[{},rules:{___Rule},x_*Power[k:K["\[Theta]",_,_],-2]==1]:=Module[{},
DebugPrint["PhaseSolver solving: ",x Power[k,-2] ==1];
{addNewRules[rules,{k->safeSqrt[x]}],addNewRules[rules,{k->-safeSqrt[x]}]}
]
PhaseSolver[{},rules:{___Rule},Power[k:K["\[Theta]",_,_],4]==1]:=Module[{},
DebugPrint["PhaseSolver solving: ", Power[k,4] ==1];
{addNewRules[rules,{k->1}],addNewRules[rules,{k->-1}],addNewRules[rules,{k->I}],addNewRules[rules,{k->-I}]}
]
PhaseSolver[{},rules:{___Rule},x_==1/;MemberQ[complicatedOnes,x]]:=Module[{},
DebugPrint["PhaseSolver ignoring a complicated identity, because a human told it to."];
{rules}
]
(*PhaseSolver[{},rules:{___Rule},x_Times\[Equal]1/;!NumericQ[x]]:=Module[{target,solutions},
DebugPrint["rules so far: ",First/@rules];
DebugPrint["solving: ",Short[x]\[Equal]1];
If[MemberQ[complicatedOnes,x],{rules},
solutions=Cases[x,k:K["\[Theta]",_,_]\[RuleDelayed](k\[Rule]k/x),1,1]~Join~Cases[x,Power[k:K["\[Theta]",_,_],-1]\[RuleDelayed](k\[Rule]x k),1,1];
If[Length[solutions]\[Equal]0,Print["PhaseSolver couldn't cope with: ",x\[Equal]1];lastPhaseSolverProblem=x;Abort[]];
{addNewRules[rules,Take[solutions,1]]}
]
]*)


safeSqrt[-1]:=I
safeSqrt[Power[x_,2]]:=x
safeSqrt[Power[x_,-2]]:=Power[x,-1]
safeSqrt/:Power[safeSqrt[x_],2]:=x
safeSqrt/:Power[safeSqrt[x_],-2]:=Power[x,-1]
safeSqrt[X_Times]:=safeSqrt/@X


PhaseSolver[X___]:=Module[{Ks,ran,diff,nsols},
Print["PhaseSolver called with arguments above its pay grade: ",{X}];
phaseSolverInvalidArguments ={X};
lastPhaseSolverProblem={X}[[-1,1]];
Ks=Union[Cases[lastPhaseSolverProblem,_K,\[Infinity]]];
ran=(#->RandomReal[])&/@Ks;
If[Chop[lastPhaseSolverProblem-1/.ran]==0,
Print["Looks like it works at a generic point, hoping for the best."];
newComplicatedOne[lastPhaseSolverProblem];
PhaseSolver[X],
If[Length[Ks]==1,
Print["Trying to solve a one variable equation numerically; might lose some solutions!"];
Print[diff=Together[Numerator[lastPhaseSolverProblem]-Denominator[lastPhaseSolverProblem]]];
Print[Plot[Evaluate[Abs[diff]],Evaluate[{Ks[[1]],0,5}]]];
nsols=Ks[[1]]/.NSolve[diff==0,Ks,WorkingPrecision->100];
Print["Found numeric solutions..."];
nsols=RootApproximant[nsols];
Print["Run RootApproximant..."];
If[MatchQ[nsols,_RootApproximant],
Print["NSolve says that anything goes, but that doesn't make sense; aborting..."];Abort[]];
If[Length[Cases[nsols,n_/;RootReduce[lastPhaseSolverProblem/.Ks[[1]]->n]!=1]]>0,
Print["found spurious solutions, aborting..."];Abort[]];
Print["found solutions for ",Ks[[1]],": ",nsols];
addNewRules[{X}[[2]],{Ks[[1]]->#}]&/@nsols,
Abort[]
]
]
]


End[];


EndPackage[];
